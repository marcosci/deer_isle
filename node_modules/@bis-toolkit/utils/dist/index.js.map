{
  "version": 3,
  "sources": ["../src/BinaryReader.ts", "../src/Lz4.ts", "../src/Lzo.ts", "../src/Lzss.ts"],
  "sourcesContent": ["/**\n * Binary reader utility for reading binary data from a buffer\n * Works with both Node.js Buffer and browser Uint8Array\n */\nexport class BinaryReader {\n    protected buffer: Uint8Array;\n    protected view: DataView;\n    protected position = 0;\n\n    constructor(buffer: Buffer | Uint8Array) {\n        // Ensure we have a Uint8Array - Buffer extends Uint8Array so instanceof check covers both\n        this.buffer = buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);\n        this.view = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);\n    }\n\n    get length(): number {\n        return this.buffer.length;\n    }\n\n    get pos(): number {\n        return this.position;\n    }\n\n    seek(offset: number, origin: 'begin' | 'current' | 'end' = 'begin'): void {\n        switch (origin) {\n            case 'begin':\n                this.position = offset;\n                break;\n            case 'current':\n                this.position += offset;\n                break;\n            case 'end':\n                this.position = this.buffer.length + offset;\n                break;\n        }\n    }\n\n    readByte(): number {\n        const value = this.view.getUint8(this.position);\n        this.position += 1;\n        return value;\n    }\n\n    readUInt16(): number {\n        const value = this.view.getUint16(this.position, true); // true = little endian\n        this.position += 2;\n        return value;\n    }\n\n    readUInt32(): number {\n        const value = this.view.getUint32(this.position, true);\n        this.position += 4;\n        return value;\n    }\n\n    readInt32(): number {\n        const value = this.view.getInt32(this.position, true);\n        this.position += 4;\n        return value;\n    }\n\n    readInt24(): number {\n        const b1 = this.view.getUint8(this.position);\n        const b2 = this.view.getUint8(this.position + 1);\n        const b3 = this.view.getUint8(this.position + 2);\n        this.position += 3;\n        return b1 | (b2 << 8) | (b3 << 16);\n    }\n\n    readBytes(count: number): Uint8Array {\n        const bytes = this.buffer.subarray(this.position, this.position + count);\n        this.position += count;\n        return bytes;\n    }\n\n    readRawString(length: number): string {\n        const bytes = this.buffer.subarray(this.position, this.position + length);\n        this.position += length;\n        return String.fromCharCode(...bytes);\n    }\n\n    readFloat(): number {\n        const value = this.view.getFloat32(this.position, true);\n        this.position += 4;\n        return value;\n    }\n\n    readBoolean(): boolean {\n        return this.readByte() !== 0;\n    }\n\n    /**\n     * Read a null-terminated C-style string\n     */\n    readCString(): string {\n        const start = this.position;\n        let end = start;\n        \n        // Find null terminator\n        while (end < this.buffer.length && this.buffer[end] !== 0) {\n            end++;\n        }\n        \n        const bytes = this.buffer.subarray(start, end);\n        this.position = end + 1; // Skip null terminator\n        \n        // Decode as UTF-8\n        const decoder = new TextDecoder('utf-8');\n        return decoder.decode(bytes);\n    }\n\n    /**\n     * Alias for readRawString for compatibility\n     */\n    readString(length: number): string {\n        return this.readRawString(length);\n    }\n}\n", "import { BinaryReader } from './BinaryReader';\n\n/**\n * Decompresses an LZ4 block with the declared size from the reader.\n * This implementation supports LZ4 chain decoder which maintains a dictionary across chunks.\n * \n * @param reader - Binary reader positioned at the start of the LZ4 block\n * @param declaredSize - The declared size of the LZ4 block (including headers)\n * @returns Decompressed data as Uint8Array\n */\nexport function decompressLz4Block(reader: BinaryReader, declaredSize: number): Uint8Array {\n    const startPos = reader.pos;\n    const targetSize = reader.readUInt32();\n    const target = new Uint8Array(targetSize);\n    let targetIdx = 0;\n\n    // LZ4 chain decoder - maintains dictionary across chunks\n    const LzBlockSize = 65536;\n    const dict = new Uint8Array(LzBlockSize);\n    let dictSize = 0;\n\n    // Each chunk is: compressedSize (int24), flags (byte), compressedData\n    while (true) {\n        const compressedSize = reader.readInt24();\n        const flags = reader.readByte();\n        if ((flags & ~0x80) !== 0) {\n            throw new Error(`Unknown LZ4 flags 0x${flags.toString(16)}`);\n        }\n\n        const compressed = reader.readBytes(compressedSize);\n        const decoded = decompressLz4BlockWithDict(compressed, dict, dictSize);\n        if (targetIdx + decoded.length > target.length) {\n            throw new Error('Decoded LZ4 data overruns target buffer');\n        }\n        target.set(decoded, targetIdx);\n        targetIdx += decoded.length;\n\n        // Update dictionary with decoded data\n        if (decoded.length >= LzBlockSize) {\n            // Copy last LZ_BLOCK_SIZE bytes\n            dict.set(decoded.subarray(decoded.length - LzBlockSize));\n            dictSize = LzBlockSize;\n        } else {\n            // Append to dictionary, possibly overflowing\n            const available = LzBlockSize - dictSize;\n            if (decoded.length <= available) {\n                dict.set(decoded, dictSize);\n                dictSize += decoded.length;\n            } else {\n                // Shift and append\n                const shift = decoded.length - available;\n                dict.copyWithin(0, shift);\n                dict.set(decoded, LzBlockSize - decoded.length);\n                dictSize = LzBlockSize;\n            }\n        }\n\n        if ((flags & 0x80) !== 0) {\n            break;\n        }\n    }\n\n    if (startPos + declaredSize !== reader.pos) {\n        throw new Error('LZ4 block length mismatch');\n    }\n    if (targetIdx !== targetSize) {\n        throw new Error(`LZ4 decoded size mismatch (expected ${targetSize}, got ${targetIdx})`);\n    }\n\n    return target;\n}\n\n/**\n * Decompresses an LZ4 block with dictionary support.\n * \n * @param compressed - Compressed data\n * @param dict - Dictionary buffer for LZ4 chain decoder\n * @param dictSize - Current size of valid data in dictionary\n * @returns Decompressed data as Uint8Array\n */\nfunction decompressLz4BlockWithDict(compressed: Uint8Array, dict: Uint8Array, dictSize: number): Uint8Array {\n    const output: number[] = [];\n    let src = 0;\n\n    while (src < compressed.length) {\n        const token = compressed[src++];\n        let literalLength = token >> 4;\n        if (literalLength === 15) {\n            let len = 0;\n            do {\n                len = compressed[src++];\n                literalLength += len;\n            } while (len === 255 && src < compressed.length);\n        }\n\n        // Copy literals\n        for (let i = 0; i < literalLength; i++) {\n            output.push(compressed[src++]);\n        }\n\n        if (src >= compressed.length) {\n            break; // No more matches\n        }\n\n        const offset = compressed[src] | (compressed[src + 1] << 8);\n        src += 2;\n\n        let matchLength = token & 0x0f;\n        if (matchLength === 15) {\n            let len = 0;\n            do {\n                len = compressed[src++];\n                matchLength += len;\n            } while (len === 255 && src < compressed.length);\n        }\n        matchLength += 4;\n\n        // LZ4 chain decoder: offset can reference into dictionary or output\n        if (offset === 0) {\n            throw new Error('Invalid LZ4 offset');\n        }\n\n        // Copy from dictionary and/or output\n        const totalAvailable = dictSize + output.length;\n        if (offset > totalAvailable) {\n            throw new Error('Invalid LZ4 offset');\n        }\n\n        for (let i = 0; i < matchLength; i++) {\n            const backPos = output.length - offset;\n            if (backPos >= 0) {\n                // Copy from output\n                output.push(output[backPos]);\n            } else {\n                // Copy from dictionary\n                const dictPos = dictSize + backPos;\n                output.push(dict[dictPos]);\n            }\n        }\n    }\n\n    return Uint8Array.from(output);\n}\n", "/**\n * LZO1X compression and decompression\n * Based on https://github.com/thaumictom/lzo-ts\n * @license GPL-3.0\n */\n\nexport interface LzoDecompressResult {\n    data: Uint8Array;\n    bytesRead: number;\n}\n\n/**\n * Compress and decompress data using the LZO1X-1 algorithm.\n */\nexport class LZO {\n    private _blockSize = 128 * 1024;\n\n    public get blockSize(): number {\n        return this._blockSize;\n    }\n\n    public set blockSize(value: number) {\n        if (value <= 0) throw new Error('Block size must be a positive integer');\n        this._blockSize = value;\n    }\n\n    private _minNewSize = this.blockSize;\n\n    private _out = new Uint8Array(256 * 1024);\n    private _cbl = 0;\n    private _t = 0;\n\n    private _inputPointer = 0;\n    private _outputPointer = 0;\n    private _matchPosition = 0;\n\n    private _skipToFirstLiteralFunc = false;\n\n    private _buffer!: Uint8Array;\n\n    private _extendBuffer(): void {\n        const newBuffer = new Uint8Array(\n            this._minNewSize + (this.blockSize - (this._minNewSize % this.blockSize))\n        );\n\n        newBuffer.set(this._out);\n\n        this._out = newBuffer;\n        this._cbl = this._out.length;\n    }\n\n    private _matchNext(): void {\n        this._minNewSize = this._outputPointer + 3;\n\n        if (this._minNewSize > this._cbl) this._extendBuffer();\n\n        this._out[this._outputPointer++] = this._buffer[this._inputPointer++];\n\n        if (this._t > 1) {\n            this._out[this._outputPointer++] = this._buffer[this._inputPointer++];\n            if (this._t > 2) {\n                this._out[this._outputPointer++] = this._buffer[this._inputPointer++];\n            }\n        }\n\n        this._t = this._buffer[this._inputPointer++];\n    }\n\n    private _matchDone(): number {\n        this._t = this._buffer[this._inputPointer - 2] & 3;\n        return this._t;\n    }\n\n    private _copyMatch(): void {\n        this._t += 2;\n        this._minNewSize = this._outputPointer + this._t;\n        if (this._minNewSize > this._cbl) {\n            this._extendBuffer();\n        }\n\n        do {\n            this._out[this._outputPointer++] = this._out[this._matchPosition++];\n        } while (--this._t > 0);\n    }\n\n    private _copyFromBuffer(): void {\n        this._minNewSize = this._outputPointer + this._t;\n        if (this._minNewSize > this._cbl) {\n            this._extendBuffer();\n        }\n\n        do {\n            this._out[this._outputPointer++] = this._buffer[this._inputPointer++];\n        } while (--this._t > 0);\n    }\n\n    private _match(): boolean | Uint8Array {\n        while (true) {\n            if (this._t >= 64) {\n                this._matchPosition =\n                    this._outputPointer -\n                    1 -\n                    ((this._t >> 2) & 7) -\n                    (this._buffer[this._inputPointer++] << 3);\n                this._t = (this._t >> 5) - 1;\n\n                this._copyMatch();\n            } else if (this._t >= 32) {\n                this._t &= 31;\n\n                if (this._t === 0) {\n                    while (this._buffer[this._inputPointer] === 0) {\n                        this._t += 255;\n                        this._inputPointer++;\n                    }\n\n                    this._t += 31 + this._buffer[this._inputPointer++];\n                }\n\n                this._matchPosition =\n                    this._outputPointer -\n                    1 -\n                    (this._buffer[this._inputPointer] >> 2) -\n                    (this._buffer[this._inputPointer + 1] << 6);\n                this._inputPointer += 2;\n\n                this._copyMatch();\n            } else if (this._t >= 16) {\n                this._matchPosition = this._outputPointer - ((this._t & 8) << 11);\n\n                this._t &= 7;\n\n                if (this._t === 0) {\n                    while (this._buffer[this._inputPointer] === 0) {\n                        this._t += 255;\n                        this._inputPointer++;\n                    }\n\n                    this._t += 7 + this._buffer[this._inputPointer++];\n                }\n\n                this._matchPosition -=\n                    (this._buffer[this._inputPointer] >> 2) +\n                    (this._buffer[this._inputPointer + 1] << 6);\n                this._inputPointer += 2;\n\n                // End reached\n                if (this._matchPosition === this._outputPointer) {\n                    return this._out.subarray(0, this._outputPointer);\n                } else {\n                    this._matchPosition -= 0x4000;\n                    this._copyMatch();\n                }\n            } else {\n                this._matchPosition =\n                    this._outputPointer - 1 - (this._t >> 2) - (this._buffer[this._inputPointer++] << 2);\n\n                this._minNewSize = this._outputPointer + 2;\n\n                if (this._minNewSize > this._cbl) {\n                    this._extendBuffer();\n                }\n\n                this._out[this._outputPointer++] = this._out[this._matchPosition++];\n                this._out[this._outputPointer++] = this._out[this._matchPosition];\n            }\n\n            if (this._matchDone() === 0) {\n                return true;\n            }\n\n            this._matchNext();\n        }\n    }\n\n    private _decompressBuffer(buffer: Uint8Array): Uint8Array {\n        this._buffer = buffer;\n\n        this._cbl = this._out.length;\n\n        this._t = 0;\n        this._inputPointer = 0;\n        this._outputPointer = 0;\n        this._matchPosition = 0;\n\n        this._skipToFirstLiteralFunc = false;\n\n        if (this._buffer[this._inputPointer] > 17) {\n            this._t = this._buffer[this._inputPointer++] - 17;\n\n            if (this._t < 4) {\n                this._matchNext();\n\n                const matched = this._match();\n\n                if (matched !== true) return matched as Uint8Array;\n            } else {\n                this._copyFromBuffer();\n                this._skipToFirstLiteralFunc = true;\n            }\n        }\n\n        while (true) {\n            if (!this._skipToFirstLiteralFunc) {\n                this._t = this._buffer[this._inputPointer++];\n\n                if (this._t >= 16) {\n                    const matched = this._match();\n\n                    if (matched !== true) return matched as Uint8Array;\n\n                    continue;\n                } else if (this._t === 0) {\n                    while (this._buffer[this._inputPointer] === 0) {\n                        this._t += 255;\n                        this._inputPointer++;\n                    }\n\n                    this._t += 15 + this._buffer[this._inputPointer++];\n                }\n\n                this._t += 3;\n                this._copyFromBuffer();\n            } else this._skipToFirstLiteralFunc = false;\n\n            this._t = this._buffer[this._inputPointer++];\n\n            if (this._t < 16) {\n                this._matchPosition = this._outputPointer - (1 + 0x0800);\n                this._matchPosition -= this._t >> 2;\n                this._matchPosition -= this._buffer[this._inputPointer++] << 2;\n\n                this._minNewSize = this._outputPointer + 3;\n\n                if (this._minNewSize > this._cbl) {\n                    this._extendBuffer();\n                }\n\n                this._out[this._outputPointer++] = this._out[this._matchPosition++];\n                this._out[this._outputPointer++] = this._out[this._matchPosition++];\n                this._out[this._outputPointer++] = this._out[this._matchPosition];\n\n                if (this._matchDone() === 0) continue;\n                else this._matchNext();\n            }\n\n            const matched = this._match();\n\n            if (matched !== true) return matched as Uint8Array;\n        }\n    }\n\n    /**\n     * Decompresses the given buffer using the LZO1X-1 algorithm.\n     * @param buffer The buffer to decompress.\n     * @returns The decompressed buffer.\n     */\n    static decompress(buffer: Uint8Array | number[]): Uint8Array {\n        return new LZO()._decompressBuffer(buffer as Uint8Array);\n    }\n\n    /**\n     * Decompresses the given buffer and returns both the decompressed data and bytes read.\n     * @param buffer The buffer to decompress.\n     * @returns Object containing decompressed data and number of bytes consumed from input.\n     */\n    static decompressWithSize(buffer: Uint8Array | number[]): LzoDecompressResult {\n        const lzo = new LZO();\n        const decompressed = lzo._decompressBuffer(buffer as Uint8Array);\n        return {\n            data: decompressed,\n            bytesRead: lzo._inputPointer\n        };\n    }\n}\n\n/**\n * Simple decompression helper\n */\nexport function lzoDecompress(src: Uint8Array | Buffer, expectedSize: number): Uint8Array {\n    const input = src instanceof Uint8Array ? src : new Uint8Array(src);\n    const decompressed = LZO.decompress(input);\n\n    if (decompressed.length !== expectedSize) {\n        throw new Error(`LZO decompression size mismatch: expected ${expectedSize}, got ${decompressed.length}`);\n    }\n\n    return decompressed;\n}\n\n/**\n * Decompression with size tracking\n */\nexport function lzoDecompressWithSize(src: Uint8Array | Buffer, expectedSize: number): LzoDecompressResult {\n    const input = src instanceof Uint8Array ? src : new Uint8Array(src);\n    const result = LZO.decompressWithSize(input);\n\n    if (result.data.length !== expectedSize) {\n        throw new Error(`LZO decompression size mismatch: expected ${expectedSize}, got ${result.data.length}`);\n    }\n\n    return result;\n}\n", "/**\n * LZSS (Lempel-Ziv-Storer-Szymanski) decompression\n */\n\nconst N = 4096;\nconst F = 18;\nconst THRESHOLD = 2;\n\n/**\n * Decompress LZSS compressed data\n * @param input Input stream containing compressed data\n * @param expectedSize Expected size of decompressed output\n * @param useSignedChecksum Whether to use signed checksum calculation\n * @returns Object containing decompressed data and bytes read\n */\nexport function lzssDecompress(\n    input: Buffer | Uint8Array,\n    inputOffset: number,\n    expectedSize: number,\n    useSignedChecksum = false\n): { data: Uint8Array; bytesRead: number } {\n    const buffer = new Array<number>(N + F - 1);\n    const dst = new Uint8Array(expectedSize);\n\n    if (expectedSize <= 0) {\n        return { data: new Uint8Array(0), bytesRead: 0 };\n    }\n\n    const startPos = inputOffset;\n    let inPos = inputOffset;\n    let iDst = 0;\n\n    let calculatedChecksum = 0;\n    let r = N - F;\n    \n    // Initialize buffer with spaces\n    for (let i = 0; i < r; i++) {\n        buffer[i] = 0x20; // space character\n    }\n\n    let flags = 0;\n    while (expectedSize > 0) {\n        if (((flags >>>= 1) & 256) === 0) {\n            const c = input[inPos++];\n            flags = c | 0xff00;\n        }\n\n        if ((flags & 1) !== 0) {\n            // Literal byte\n            const c = input[inPos++];\n            calculatedChecksum = (calculatedChecksum + (useSignedChecksum ? (c << 24 >> 24) : c)) | 0;\n            dst[iDst++] = c;\n            expectedSize--;\n            \n            // Update ring buffer\n            buffer[r] = c;\n            r = (r + 1) & (N - 1);\n        } else {\n            // Match (backreference)\n            const i = input[inPos++];\n            const j = input[inPos++];\n            const offset = i | ((j & 0xf0) << 4);\n            const length = (j & 0x0f) + THRESHOLD;\n\n            if (length + 1 > expectedSize + length - THRESHOLD) {\n                throw new Error('LZSS overflow');\n            }\n\n            let ii = r - offset;\n            const jj = length + ii;\n            \n            for (; ii <= jj; ii++) {\n                const c = buffer[ii & (N - 1)];\n                calculatedChecksum = (calculatedChecksum + (useSignedChecksum ? (c << 24 >> 24) : c)) | 0;\n                \n                // Save byte\n                dst[iDst++] = c;\n                expectedSize--;\n                \n                // Update ring buffer\n                buffer[r] = c;\n                r = (r + 1) & (N - 1);\n            }\n        }\n    }\n\n    // Read and verify checksum using DataView\n    const view = new DataView(input.buffer, input.byteOffset, input.byteLength);\n    const checksum = view.getInt32(inPos, true); // true = little endian\n    inPos += 4;\n\n    if (checksum !== calculatedChecksum) {\n        throw new Error(`Checksum mismatch: expected ${checksum}, got ${calculatedChecksum}`);\n    }\n\n    return {\n        data: dst,\n        bytesRead: inPos - startPos\n    };\n}\n\n/**\n * Calculate CRC/checksum for data\n */\nexport function calculateChecksum(data: Buffer, signed = false): number {\n    let checksum = 0;\n    for (const byte of data) {\n        checksum = (checksum + (signed ? (byte << 24 >> 24) : byte)) | 0;\n    }\n    return checksum;\n}\n"],
  "mappings": "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",
  "names": ["matched"]
}
