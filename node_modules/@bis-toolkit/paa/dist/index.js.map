{
  "version": 3,
  "sources": ["../src/PaaType.ts", "../src/PaaColor.ts", "../src/Palette.ts", "../../utils/src/BinaryReader.ts", "../../utils/src/Lz4.ts", "../../utils/src/Lzo.ts", "../../utils/src/Lzss.ts", "../../bcn/src/utils.ts", "../../bcn/src/bc1.ts", "../../bcn/src/bc2.ts", "../../bcn/src/bc3.ts", "../../bcn/src/bc4.ts", "../../bcn/src/bc5.ts", "../../bcn/src/bc7.ts", "../src/FormatConverter.ts", "../src/Mipmap.ts", "../src/ChannelSwizzler.ts", "../src/Paa.ts"],
  "sourcesContent": ["/**\n * PAA texture format types\n */\nexport enum PaaType {\n    DXT1 = 0xff01,\n    DXT2 = 0xff02,\n    DXT3 = 0xff03,\n    DXT4 = 0xff04,\n    DXT5 = 0xff05,\n    RGBA_5551 = 0x1555,\n    RGBA_4444 = 0x4444,\n    RGBA_8888 = 0x8888,\n    AI88 = 0x8080\n}\n", "/**\n * Represents a color in PAA format (ARGB)\n */\nexport class PaaColor {\n    private _value: number;\n\n    constructor(value: number);\n    constructor(red: number, green: number, blue: number, alpha?: number);\n    constructor(valueOrRed: number, green?: number, blue?: number, alpha = 0xff) {\n        if (green === undefined) {\n            // Single argument constructor - uint value\n            this._value = valueOrRed >>> 0; // Ensure unsigned\n        } else {\n            // Multi-argument constructor - r, g, b, a\n            this._value = PaaColor.colorToUint(valueOrRed, green, blue ?? 0, alpha ?? 0);\n        }\n    }\n\n    get alpha(): number {\n        return (this._value >>> 24) & 0xff;\n    }\n\n    get red(): number {\n        return (this._value >>> 16) & 0xff;\n    }\n\n    get green(): number {\n        return (this._value >>> 8) & 0xff;\n    }\n\n    get blue(): number {\n        return this._value & 0xff;\n    }\n\n    get color(): number {\n        return this._value;\n    }\n\n    private static colorToUint(r: number, g: number, b: number, a: number): number {\n        return ((a << 24) | (r << 16) | (g << 8) | b) >>> 0; // >>> 0 ensures unsigned\n    }\n\n    static fromFloat(red: number, green: number, blue: number, alpha: number): PaaColor {\n        return new PaaColor(\n            Math.floor(red * 255),\n            Math.floor(green * 255),\n            Math.floor(blue * 255),\n            Math.floor(alpha * 255)\n        );\n    }\n}\n", "import { PaaColor } from './PaaColor';\nimport { BinaryReader } from '@bis-toolkit/utils';\n\n/**\n * Represents a color palette for indexed PAA formats\n */\nexport class Palette {\n    public colors: PaaColor[] = [];\n\n    read(br: BinaryReader): void {\n        const nPaletteTriplets = br.readUInt16();\n        this.colors = [];\n        for (let i = 0; i < nPaletteTriplets; i++) {\n            const b = br.readByte();\n            const g = br.readByte();\n            const r = br.readByte();\n            this.colors.push(new PaaColor(r, g, b));\n        }\n    }\n}\n", "/**\n * Binary reader utility for reading binary data from a buffer\n * Works with both Node.js Buffer and browser Uint8Array\n */\nexport class BinaryReader {\n    protected buffer: Uint8Array;\n    protected view: DataView;\n    protected position = 0;\n\n    constructor(buffer: Buffer | Uint8Array) {\n        // Ensure we have a Uint8Array - Buffer extends Uint8Array so instanceof check covers both\n        this.buffer = buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);\n        this.view = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);\n    }\n\n    get length(): number {\n        return this.buffer.length;\n    }\n\n    get pos(): number {\n        return this.position;\n    }\n\n    seek(offset: number, origin: 'begin' | 'current' | 'end' = 'begin'): void {\n        switch (origin) {\n            case 'begin':\n                this.position = offset;\n                break;\n            case 'current':\n                this.position += offset;\n                break;\n            case 'end':\n                this.position = this.buffer.length + offset;\n                break;\n        }\n    }\n\n    readByte(): number {\n        const value = this.view.getUint8(this.position);\n        this.position += 1;\n        return value;\n    }\n\n    readUInt16(): number {\n        const value = this.view.getUint16(this.position, true); // true = little endian\n        this.position += 2;\n        return value;\n    }\n\n    readUInt32(): number {\n        const value = this.view.getUint32(this.position, true);\n        this.position += 4;\n        return value;\n    }\n\n    readInt32(): number {\n        const value = this.view.getInt32(this.position, true);\n        this.position += 4;\n        return value;\n    }\n\n    readInt24(): number {\n        const b1 = this.view.getUint8(this.position);\n        const b2 = this.view.getUint8(this.position + 1);\n        const b3 = this.view.getUint8(this.position + 2);\n        this.position += 3;\n        return b1 | (b2 << 8) | (b3 << 16);\n    }\n\n    readBytes(count: number): Uint8Array {\n        const bytes = this.buffer.subarray(this.position, this.position + count);\n        this.position += count;\n        return bytes;\n    }\n\n    readRawString(length: number): string {\n        const bytes = this.buffer.subarray(this.position, this.position + length);\n        this.position += length;\n        return String.fromCharCode(...bytes);\n    }\n\n    readFloat(): number {\n        const value = this.view.getFloat32(this.position, true);\n        this.position += 4;\n        return value;\n    }\n\n    readBoolean(): boolean {\n        return this.readByte() !== 0;\n    }\n\n    /**\n     * Read a null-terminated C-style string\n     */\n    readCString(): string {\n        const start = this.position;\n        let end = start;\n        \n        // Find null terminator\n        while (end < this.buffer.length && this.buffer[end] !== 0) {\n            end++;\n        }\n        \n        const bytes = this.buffer.subarray(start, end);\n        this.position = end + 1; // Skip null terminator\n        \n        // Decode as UTF-8\n        const decoder = new TextDecoder('utf-8');\n        return decoder.decode(bytes);\n    }\n\n    /**\n     * Alias for readRawString for compatibility\n     */\n    readString(length: number): string {\n        return this.readRawString(length);\n    }\n}\n", "import { BinaryReader } from './BinaryReader';\n\n/**\n * Decompresses an LZ4 block with the declared size from the reader.\n * This implementation supports LZ4 chain decoder which maintains a dictionary across chunks.\n * \n * @param reader - Binary reader positioned at the start of the LZ4 block\n * @param declaredSize - The declared size of the LZ4 block (including headers)\n * @returns Decompressed data as Uint8Array\n */\nexport function decompressLz4Block(reader: BinaryReader, declaredSize: number): Uint8Array {\n    const startPos = reader.pos;\n    const targetSize = reader.readUInt32();\n    const target = new Uint8Array(targetSize);\n    let targetIdx = 0;\n\n    // LZ4 chain decoder - maintains dictionary across chunks\n    const LzBlockSize = 65536;\n    const dict = new Uint8Array(LzBlockSize);\n    let dictSize = 0;\n\n    // Each chunk is: compressedSize (int24), flags (byte), compressedData\n    while (true) {\n        const compressedSize = reader.readInt24();\n        const flags = reader.readByte();\n        if ((flags & ~0x80) !== 0) {\n            throw new Error(`Unknown LZ4 flags 0x${flags.toString(16)}`);\n        }\n\n        const compressed = reader.readBytes(compressedSize);\n        const decoded = decompressLz4BlockWithDict(compressed, dict, dictSize);\n        if (targetIdx + decoded.length > target.length) {\n            throw new Error('Decoded LZ4 data overruns target buffer');\n        }\n        target.set(decoded, targetIdx);\n        targetIdx += decoded.length;\n\n        // Update dictionary with decoded data\n        if (decoded.length >= LzBlockSize) {\n            // Copy last LZ_BLOCK_SIZE bytes\n            dict.set(decoded.subarray(decoded.length - LzBlockSize));\n            dictSize = LzBlockSize;\n        } else {\n            // Append to dictionary, possibly overflowing\n            const available = LzBlockSize - dictSize;\n            if (decoded.length <= available) {\n                dict.set(decoded, dictSize);\n                dictSize += decoded.length;\n            } else {\n                // Shift and append\n                const shift = decoded.length - available;\n                dict.copyWithin(0, shift);\n                dict.set(decoded, LzBlockSize - decoded.length);\n                dictSize = LzBlockSize;\n            }\n        }\n\n        if ((flags & 0x80) !== 0) {\n            break;\n        }\n    }\n\n    if (startPos + declaredSize !== reader.pos) {\n        throw new Error('LZ4 block length mismatch');\n    }\n    if (targetIdx !== targetSize) {\n        throw new Error(`LZ4 decoded size mismatch (expected ${targetSize}, got ${targetIdx})`);\n    }\n\n    return target;\n}\n\n/**\n * Decompresses an LZ4 block with dictionary support.\n * \n * @param compressed - Compressed data\n * @param dict - Dictionary buffer for LZ4 chain decoder\n * @param dictSize - Current size of valid data in dictionary\n * @returns Decompressed data as Uint8Array\n */\nfunction decompressLz4BlockWithDict(compressed: Uint8Array, dict: Uint8Array, dictSize: number): Uint8Array {\n    const output: number[] = [];\n    let src = 0;\n\n    while (src < compressed.length) {\n        const token = compressed[src++];\n        let literalLength = token >> 4;\n        if (literalLength === 15) {\n            let len = 0;\n            do {\n                len = compressed[src++];\n                literalLength += len;\n            } while (len === 255 && src < compressed.length);\n        }\n\n        // Copy literals\n        for (let i = 0; i < literalLength; i++) {\n            output.push(compressed[src++]);\n        }\n\n        if (src >= compressed.length) {\n            break; // No more matches\n        }\n\n        const offset = compressed[src] | (compressed[src + 1] << 8);\n        src += 2;\n\n        let matchLength = token & 0x0f;\n        if (matchLength === 15) {\n            let len = 0;\n            do {\n                len = compressed[src++];\n                matchLength += len;\n            } while (len === 255 && src < compressed.length);\n        }\n        matchLength += 4;\n\n        // LZ4 chain decoder: offset can reference into dictionary or output\n        if (offset === 0) {\n            throw new Error('Invalid LZ4 offset');\n        }\n\n        // Copy from dictionary and/or output\n        const totalAvailable = dictSize + output.length;\n        if (offset > totalAvailable) {\n            throw new Error('Invalid LZ4 offset');\n        }\n\n        for (let i = 0; i < matchLength; i++) {\n            const backPos = output.length - offset;\n            if (backPos >= 0) {\n                // Copy from output\n                output.push(output[backPos]);\n            } else {\n                // Copy from dictionary\n                const dictPos = dictSize + backPos;\n                output.push(dict[dictPos]);\n            }\n        }\n    }\n\n    return Uint8Array.from(output);\n}\n", "/**\n * LZO1X compression and decompression\n * Based on https://github.com/thaumictom/lzo-ts\n * @license GPL-3.0\n */\n\nexport interface LzoDecompressResult {\n    data: Uint8Array;\n    bytesRead: number;\n}\n\n/**\n * Compress and decompress data using the LZO1X-1 algorithm.\n */\nexport class LZO {\n    private _blockSize = 128 * 1024;\n\n    public get blockSize(): number {\n        return this._blockSize;\n    }\n\n    public set blockSize(value: number) {\n        if (value <= 0) throw new Error('Block size must be a positive integer');\n        this._blockSize = value;\n    }\n\n    private _minNewSize = this.blockSize;\n\n    private _out = new Uint8Array(256 * 1024);\n    private _cbl = 0;\n    private _t = 0;\n\n    private _inputPointer = 0;\n    private _outputPointer = 0;\n    private _matchPosition = 0;\n\n    private _skipToFirstLiteralFunc = false;\n\n    private _buffer!: Uint8Array;\n\n    private _extendBuffer(): void {\n        const newBuffer = new Uint8Array(\n            this._minNewSize + (this.blockSize - (this._minNewSize % this.blockSize))\n        );\n\n        newBuffer.set(this._out);\n\n        this._out = newBuffer;\n        this._cbl = this._out.length;\n    }\n\n    private _matchNext(): void {\n        this._minNewSize = this._outputPointer + 3;\n\n        if (this._minNewSize > this._cbl) this._extendBuffer();\n\n        this._out[this._outputPointer++] = this._buffer[this._inputPointer++];\n\n        if (this._t > 1) {\n            this._out[this._outputPointer++] = this._buffer[this._inputPointer++];\n            if (this._t > 2) {\n                this._out[this._outputPointer++] = this._buffer[this._inputPointer++];\n            }\n        }\n\n        this._t = this._buffer[this._inputPointer++];\n    }\n\n    private _matchDone(): number {\n        this._t = this._buffer[this._inputPointer - 2] & 3;\n        return this._t;\n    }\n\n    private _copyMatch(): void {\n        this._t += 2;\n        this._minNewSize = this._outputPointer + this._t;\n        if (this._minNewSize > this._cbl) {\n            this._extendBuffer();\n        }\n\n        do {\n            this._out[this._outputPointer++] = this._out[this._matchPosition++];\n        } while (--this._t > 0);\n    }\n\n    private _copyFromBuffer(): void {\n        this._minNewSize = this._outputPointer + this._t;\n        if (this._minNewSize > this._cbl) {\n            this._extendBuffer();\n        }\n\n        do {\n            this._out[this._outputPointer++] = this._buffer[this._inputPointer++];\n        } while (--this._t > 0);\n    }\n\n    private _match(): boolean | Uint8Array {\n        while (true) {\n            if (this._t >= 64) {\n                this._matchPosition =\n                    this._outputPointer -\n                    1 -\n                    ((this._t >> 2) & 7) -\n                    (this._buffer[this._inputPointer++] << 3);\n                this._t = (this._t >> 5) - 1;\n\n                this._copyMatch();\n            } else if (this._t >= 32) {\n                this._t &= 31;\n\n                if (this._t === 0) {\n                    while (this._buffer[this._inputPointer] === 0) {\n                        this._t += 255;\n                        this._inputPointer++;\n                    }\n\n                    this._t += 31 + this._buffer[this._inputPointer++];\n                }\n\n                this._matchPosition =\n                    this._outputPointer -\n                    1 -\n                    (this._buffer[this._inputPointer] >> 2) -\n                    (this._buffer[this._inputPointer + 1] << 6);\n                this._inputPointer += 2;\n\n                this._copyMatch();\n            } else if (this._t >= 16) {\n                this._matchPosition = this._outputPointer - ((this._t & 8) << 11);\n\n                this._t &= 7;\n\n                if (this._t === 0) {\n                    while (this._buffer[this._inputPointer] === 0) {\n                        this._t += 255;\n                        this._inputPointer++;\n                    }\n\n                    this._t += 7 + this._buffer[this._inputPointer++];\n                }\n\n                this._matchPosition -=\n                    (this._buffer[this._inputPointer] >> 2) +\n                    (this._buffer[this._inputPointer + 1] << 6);\n                this._inputPointer += 2;\n\n                // End reached\n                if (this._matchPosition === this._outputPointer) {\n                    return this._out.subarray(0, this._outputPointer);\n                } else {\n                    this._matchPosition -= 0x4000;\n                    this._copyMatch();\n                }\n            } else {\n                this._matchPosition =\n                    this._outputPointer - 1 - (this._t >> 2) - (this._buffer[this._inputPointer++] << 2);\n\n                this._minNewSize = this._outputPointer + 2;\n\n                if (this._minNewSize > this._cbl) {\n                    this._extendBuffer();\n                }\n\n                this._out[this._outputPointer++] = this._out[this._matchPosition++];\n                this._out[this._outputPointer++] = this._out[this._matchPosition];\n            }\n\n            if (this._matchDone() === 0) {\n                return true;\n            }\n\n            this._matchNext();\n        }\n    }\n\n    private _decompressBuffer(buffer: Uint8Array): Uint8Array {\n        this._buffer = buffer;\n\n        this._cbl = this._out.length;\n\n        this._t = 0;\n        this._inputPointer = 0;\n        this._outputPointer = 0;\n        this._matchPosition = 0;\n\n        this._skipToFirstLiteralFunc = false;\n\n        if (this._buffer[this._inputPointer] > 17) {\n            this._t = this._buffer[this._inputPointer++] - 17;\n\n            if (this._t < 4) {\n                this._matchNext();\n\n                const matched = this._match();\n\n                if (matched !== true) return matched as Uint8Array;\n            } else {\n                this._copyFromBuffer();\n                this._skipToFirstLiteralFunc = true;\n            }\n        }\n\n        while (true) {\n            if (!this._skipToFirstLiteralFunc) {\n                this._t = this._buffer[this._inputPointer++];\n\n                if (this._t >= 16) {\n                    const matched = this._match();\n\n                    if (matched !== true) return matched as Uint8Array;\n\n                    continue;\n                } else if (this._t === 0) {\n                    while (this._buffer[this._inputPointer] === 0) {\n                        this._t += 255;\n                        this._inputPointer++;\n                    }\n\n                    this._t += 15 + this._buffer[this._inputPointer++];\n                }\n\n                this._t += 3;\n                this._copyFromBuffer();\n            } else this._skipToFirstLiteralFunc = false;\n\n            this._t = this._buffer[this._inputPointer++];\n\n            if (this._t < 16) {\n                this._matchPosition = this._outputPointer - (1 + 0x0800);\n                this._matchPosition -= this._t >> 2;\n                this._matchPosition -= this._buffer[this._inputPointer++] << 2;\n\n                this._minNewSize = this._outputPointer + 3;\n\n                if (this._minNewSize > this._cbl) {\n                    this._extendBuffer();\n                }\n\n                this._out[this._outputPointer++] = this._out[this._matchPosition++];\n                this._out[this._outputPointer++] = this._out[this._matchPosition++];\n                this._out[this._outputPointer++] = this._out[this._matchPosition];\n\n                if (this._matchDone() === 0) continue;\n                else this._matchNext();\n            }\n\n            const matched = this._match();\n\n            if (matched !== true) return matched as Uint8Array;\n        }\n    }\n\n    /**\n     * Decompresses the given buffer using the LZO1X-1 algorithm.\n     * @param buffer The buffer to decompress.\n     * @returns The decompressed buffer.\n     */\n    static decompress(buffer: Uint8Array | number[]): Uint8Array {\n        return new LZO()._decompressBuffer(buffer as Uint8Array);\n    }\n\n    /**\n     * Decompresses the given buffer and returns both the decompressed data and bytes read.\n     * @param buffer The buffer to decompress.\n     * @returns Object containing decompressed data and number of bytes consumed from input.\n     */\n    static decompressWithSize(buffer: Uint8Array | number[]): LzoDecompressResult {\n        const lzo = new LZO();\n        const decompressed = lzo._decompressBuffer(buffer as Uint8Array);\n        return {\n            data: decompressed,\n            bytesRead: lzo._inputPointer\n        };\n    }\n}\n\n/**\n * Simple decompression helper\n */\nexport function lzoDecompress(src: Uint8Array | Buffer, expectedSize: number): Uint8Array {\n    const input = src instanceof Uint8Array ? src : new Uint8Array(src);\n    const decompressed = LZO.decompress(input);\n\n    if (decompressed.length !== expectedSize) {\n        throw new Error(`LZO decompression size mismatch: expected ${expectedSize}, got ${decompressed.length}`);\n    }\n\n    return decompressed;\n}\n\n/**\n * Decompression with size tracking\n */\nexport function lzoDecompressWithSize(src: Uint8Array | Buffer, expectedSize: number): LzoDecompressResult {\n    const input = src instanceof Uint8Array ? src : new Uint8Array(src);\n    const result = LZO.decompressWithSize(input);\n\n    if (result.data.length !== expectedSize) {\n        throw new Error(`LZO decompression size mismatch: expected ${expectedSize}, got ${result.data.length}`);\n    }\n\n    return result;\n}\n", "/**\n * LZSS (Lempel-Ziv-Storer-Szymanski) decompression\n */\n\nconst N = 4096;\nconst F = 18;\nconst THRESHOLD = 2;\n\n/**\n * Decompress LZSS compressed data\n * @param input Input stream containing compressed data\n * @param expectedSize Expected size of decompressed output\n * @param useSignedChecksum Whether to use signed checksum calculation\n * @returns Object containing decompressed data and bytes read\n */\nexport function lzssDecompress(\n    input: Buffer | Uint8Array,\n    inputOffset: number,\n    expectedSize: number,\n    useSignedChecksum = false\n): { data: Uint8Array; bytesRead: number } {\n    const buffer = new Array<number>(N + F - 1);\n    const dst = new Uint8Array(expectedSize);\n\n    if (expectedSize <= 0) {\n        return { data: new Uint8Array(0), bytesRead: 0 };\n    }\n\n    const startPos = inputOffset;\n    let inPos = inputOffset;\n    let iDst = 0;\n\n    let calculatedChecksum = 0;\n    let r = N - F;\n    \n    // Initialize buffer with spaces\n    for (let i = 0; i < r; i++) {\n        buffer[i] = 0x20; // space character\n    }\n\n    let flags = 0;\n    while (expectedSize > 0) {\n        if (((flags >>>= 1) & 256) === 0) {\n            const c = input[inPos++];\n            flags = c | 0xff00;\n        }\n\n        if ((flags & 1) !== 0) {\n            // Literal byte\n            const c = input[inPos++];\n            calculatedChecksum = (calculatedChecksum + (useSignedChecksum ? (c << 24 >> 24) : c)) | 0;\n            dst[iDst++] = c;\n            expectedSize--;\n            \n            // Update ring buffer\n            buffer[r] = c;\n            r = (r + 1) & (N - 1);\n        } else {\n            // Match (backreference)\n            const i = input[inPos++];\n            const j = input[inPos++];\n            const offset = i | ((j & 0xf0) << 4);\n            const length = (j & 0x0f) + THRESHOLD;\n\n            if (length + 1 > expectedSize + length - THRESHOLD) {\n                throw new Error('LZSS overflow');\n            }\n\n            let ii = r - offset;\n            const jj = length + ii;\n            \n            for (; ii <= jj; ii++) {\n                const c = buffer[ii & (N - 1)];\n                calculatedChecksum = (calculatedChecksum + (useSignedChecksum ? (c << 24 >> 24) : c)) | 0;\n                \n                // Save byte\n                dst[iDst++] = c;\n                expectedSize--;\n                \n                // Update ring buffer\n                buffer[r] = c;\n                r = (r + 1) & (N - 1);\n            }\n        }\n    }\n\n    // Read and verify checksum using DataView\n    const view = new DataView(input.buffer, input.byteOffset, input.byteLength);\n    const checksum = view.getInt32(inPos, true); // true = little endian\n    inPos += 4;\n\n    if (checksum !== calculatedChecksum) {\n        throw new Error(`Checksum mismatch: expected ${checksum}, got ${calculatedChecksum}`);\n    }\n\n    return {\n        data: dst,\n        bytesRead: inPos - startPos\n    };\n}\n\n/**\n * Calculate CRC/checksum for data\n */\nexport function calculateChecksum(data: Buffer, signed = false): number {\n    let checksum = 0;\n    for (const byte of data) {\n        checksum = (checksum + (signed ? (byte << 24 >> 24) : byte)) | 0;\n    }\n    return checksum;\n}\n", "/**\n * Shared utilities for BC decoders\n * Source: https://github.com/Nominom/BCnEncoder.NET\n */\n\nexport interface ColorRgba32 {\n    r: number;\n    g: number;\n    b: number;\n    a: number;\n}\n\nexport interface ColorRgb24 {\n    r: number;\n    g: number;\n    b: number;\n}\n\n// RGB565 color (5 bits red, 6 bits green, 5 bits blue)\nexport class ColorRgb565 {\n    data: number;\n\n    constructor(r?: number, g?: number, b?: number) {\n        if (r !== undefined && g !== undefined && b !== undefined) {\n            // Convert 8-bit RGB to 565\n            const r5 = (r >> 3) & 0x1F;\n            const g6 = (g >> 2) & 0x3F;\n            const b5 = (b >> 3) & 0x1F;\n            this.data = (r5 << 11) | (g6 << 5) | b5;\n        } else {\n            this.data = 0;\n        }\n    }\n\n    toColorRgb24(): ColorRgb24 {\n        const r5 = (this.data >> 11) & 0x1F;\n        const g6 = (this.data >> 5) & 0x3F;\n        const b5 = this.data & 0x1F;\n\n        // Expand to 8-bit\n        const r = (r5 << 3) | (r5 >> 2);\n        const g = (g6 << 2) | (g6 >> 4);\n        const b = (b5 << 3) | (b5 >> 2);\n\n        return { r, g, b };\n    }\n}\n\n// Color interpolation helpers\nexport function interpolateHalf(c0: ColorRgb24, c1: ColorRgb24): ColorRgb24 {\n    return {\n        r: ((c0.r + c1.r) / 2) | 0,\n        g: ((c0.g + c1.g) / 2) | 0,\n        b: ((c0.b + c1.b) / 2) | 0\n    };\n}\n\nexport function interpolateThird(c0: ColorRgb24, c1: ColorRgb24, step: number): ColorRgb24 {\n    if (step === 1) {\n        return {\n            r: ((2 * c0.r + c1.r) / 3) | 0,\n            g: ((2 * c0.g + c1.g) / 3) | 0,\n            b: ((2 * c0.b + c1.b) / 3) | 0\n        };\n    } else { // step === 2\n        return {\n            r: ((c0.r + 2 * c1.r) / 3) | 0,\n            g: ((c0.g + 2 * c1.g) / 3) | 0,\n            b: ((c0.b + 2 * c1.b) / 3) | 0\n        };\n    }\n}\n\n// Byte interpolation for alpha/component channels\nexport function interpolateByteFifth(e0: number, e1: number, step: number): number {\n    if (step === 1) return ((4 * e0 + e1) / 5) | 0;\n    if (step === 2) return ((3 * e0 + 2 * e1) / 5) | 0;\n    if (step === 3) return ((2 * e0 + 3 * e1) / 5) | 0;\n    return ((e0 + 4 * e1) / 5) | 0; // step === 4\n}\n\nexport function interpolateByteSeventh(e0: number, e1: number, step: number): number {\n    if (step === 1) return ((6 * e0 + e1) / 7) | 0;\n    if (step === 2) return ((5 * e0 + 2 * e1) / 7) | 0;\n    if (step === 3) return ((4 * e0 + 3 * e1) / 7) | 0;\n    if (step === 4) return ((3 * e0 + 4 * e1) / 7) | 0;\n    if (step === 5) return ((2 * e0 + 5 * e1) / 7) | 0;\n    return ((e0 + 6 * e1) / 7) | 0; // step === 6\n}\n", "/**\n * BC1 (DXT1) Decoder\n * Source: https://github.com/Nominom/BCnEncoder.NET\n */\n\nimport { ColorRgb565, interpolateHalf, interpolateThird } from './utils';\n\nexport function decodeBC1(data: DataView, width: number, height: number, useAlpha = false): Uint8Array {\n    const rgba = new Uint8Array(width * height * 4);\n    const blocksX = Math.ceil(width / 4);\n    const blocksY = Math.ceil(height / 4);\n\n    let offset = 0;\n    for (let by = 0; by < blocksY; by++) {\n        for (let bx = 0; bx < blocksX; bx++) {\n            const color0Data = data.getUint16(offset, true);\n            const color1Data = data.getUint16(offset + 2, true);\n            const indices = data.getUint32(offset + 4, true);\n\n            const color0 = new ColorRgb565();\n            color0.data = color0Data;\n            const color1 = new ColorRgb565();\n            color1.data = color1Data;\n\n            const c0 = color0.toColorRgb24();\n            const c1 = color1.toColorRgb24();\n\n            const hasAlphaOrBlack = color0Data <= color1Data;\n            const actualUseAlpha = useAlpha && hasAlphaOrBlack;\n\n            // Build color palette\n            const colors = hasAlphaOrBlack ? [\n                c0,\n                c1,\n                interpolateHalf(c0, c1),\n                { r: 0, g: 0, b: 0 }\n            ] : [\n                c0,\n                c1,\n                interpolateThird(c0, c1, 1),\n                interpolateThird(c0, c1, 2)\n            ];\n\n            // Decode 4x4 block\n            for (let y = 0; y < 4; y++) {\n                for (let x = 0; x < 4; x++) {\n                    const px = bx * 4 + x;\n                    const py = by * 4 + y;\n\n                    if (px < width && py < height) {\n                        const i = y * 4 + x;\n                        const colorIndex = (indices >> (i * 2)) & 0b11;\n                        const color = colors[colorIndex];\n\n                        const dstIdx = (py * width + px) * 4;\n\n                        if (actualUseAlpha && colorIndex === 3) {\n                            rgba[dstIdx] = 0;\n                            rgba[dstIdx + 1] = 0;\n                            rgba[dstIdx + 2] = 0;\n                            rgba[dstIdx + 3] = 0;\n                        } else {\n                            rgba[dstIdx] = color.r;\n                            rgba[dstIdx + 1] = color.g;\n                            rgba[dstIdx + 2] = color.b;\n                            rgba[dstIdx + 3] = 255;\n                        }\n                    }\n                }\n            }\n\n            offset += 8;\n        }\n    }\n\n    return rgba;\n}\n", "/**\n * BC2 (DXT3) Decoder - RGBA with explicit alpha\n * Source: https://github.com/Nominom/BCnEncoder.NET\n */\n\nimport { ColorRgb565, interpolateThird } from './utils';\n\nexport function decodeBC2(data: DataView, width: number, height: number): Uint8Array {\n    const rgba = new Uint8Array(width * height * 4);\n    const blocksX = Math.ceil(width / 4);\n    const blocksY = Math.ceil(height / 4);\n\n    let offset = 0;\n    for (let by = 0; by < blocksY; by++) {\n        for (let bx = 0; bx < blocksX; bx++) {\n            // Read alpha block (64 bits = 16 pixels * 4 bits each)\n            const alphaLow = data.getUint32(offset, true);\n            const alphaHigh = data.getUint32(offset + 4, true);\n\n            // Read color block\n            const color0Data = data.getUint16(offset + 8, true);\n            const color1Data = data.getUint16(offset + 10, true);\n            const indices = data.getUint32(offset + 12, true);\n\n            const color0 = new ColorRgb565();\n            color0.data = color0Data;\n            const color1 = new ColorRgb565();\n            color1.data = color1Data;\n\n            const c0 = color0.toColorRgb24();\n            const c1 = color1.toColorRgb24();\n\n            // Build color palette (BC2 always uses 4-color mode)\n            const colors = [\n                c0,\n                c1,\n                interpolateThird(c0, c1, 1),\n                interpolateThird(c0, c1, 2)\n            ];\n\n            // Decode 4x4 block\n            for (let y = 0; y < 4; y++) {\n                for (let x = 0; x < 4; x++) {\n                    const px = bx * 4 + x;\n                    const py = by * 4 + y;\n\n                    if (px < width && py < height) {\n                        const i = y * 4 + x;\n                        const colorIndex = (indices >> (i * 2)) & 0b11;\n                        const color = colors[colorIndex];\n\n                        // Extract 4-bit alpha\n                        const alphaIndex = i * 4;\n                        let alpha: number;\n                        if (alphaIndex < 32) {\n                            alpha = (alphaLow >> alphaIndex) & 0xF;\n                        } else {\n                            alpha = (alphaHigh >> (alphaIndex - 32)) & 0xF;\n                        }\n                        // Expand 4-bit alpha to 8-bit\n                        alpha = (alpha << 4) | alpha;\n\n                        const dstIdx = (py * width + px) * 4;\n                        rgba[dstIdx] = color.r;\n                        rgba[dstIdx + 1] = color.g;\n                        rgba[dstIdx + 2] = color.b;\n                        rgba[dstIdx + 3] = alpha;\n                    }\n                }\n            }\n\n            offset += 16;\n        }\n    }\n\n    return rgba;\n}\n", "/**\n * BC3 (DXT5) Decoder - RGBA with interpolated alpha\n * Source: https://github.com/Nominom/BCnEncoder.NET\n */\n\nimport { ColorRgb565, interpolateThird, interpolateByteFifth, interpolateByteSeventh } from './utils';\n\nfunction decodeAlphaBlock(alphaData: bigint): number[] {\n    const alpha = new Array<number>(16);\n\n    const alpha0 = Number(alphaData & 0xFFn);\n    const alpha1 = Number((alphaData >> 8n) & 0xFFn);\n\n    // Build alpha palette\n    const alphas = alpha0 > alpha1 ? [\n        alpha0,\n        alpha1,\n        interpolateByteSeventh(alpha0, alpha1, 1),\n        interpolateByteSeventh(alpha0, alpha1, 2),\n        interpolateByteSeventh(alpha0, alpha1, 3),\n        interpolateByteSeventh(alpha0, alpha1, 4),\n        interpolateByteSeventh(alpha0, alpha1, 5),\n        interpolateByteSeventh(alpha0, alpha1, 6)\n    ] : [\n        alpha0,\n        alpha1,\n        interpolateByteFifth(alpha0, alpha1, 1),\n        interpolateByteFifth(alpha0, alpha1, 2),\n        interpolateByteFifth(alpha0, alpha1, 3),\n        interpolateByteFifth(alpha0, alpha1, 4),\n        0,\n        255\n    ];\n\n    // Decode indices (3 bits per pixel, 48 bits total starting at bit 16)\n    for (let i = 0; i < 16; i++) {\n        const bitOffset = 16 + i * 3;\n        const index = Number((alphaData >> BigInt(bitOffset)) & 0x7n);\n        alpha[i] = alphas[index];\n    }\n\n    return alpha;\n}\n\nexport function decodeBC3(data: DataView, width: number, height: number): Uint8Array {\n    const rgba = new Uint8Array(width * height * 4);\n    const blocksX = Math.ceil(width / 4);\n    const blocksY = Math.ceil(height / 4);\n\n    let offset = 0;\n    for (let by = 0; by < blocksY; by++) {\n        for (let bx = 0; bx < blocksX; bx++) {\n            // Read alpha block (64 bits)\n            const alphaBlock = data.getBigUint64(offset, true);\n            const alphas = decodeAlphaBlock(alphaBlock);\n\n            // Read color block\n            const color0Data = data.getUint16(offset + 8, true);\n            const color1Data = data.getUint16(offset + 10, true);\n            const indices = data.getUint32(offset + 12, true);\n\n            const color0 = new ColorRgb565();\n            color0.data = color0Data;\n            const color1 = new ColorRgb565();\n            color1.data = color1Data;\n\n            const c0 = color0.toColorRgb24();\n            const c1 = color1.toColorRgb24();\n\n            // Build color palette (BC3 always uses 4-color mode)\n            const colors = [\n                c0,\n                c1,\n                interpolateThird(c0, c1, 1),\n                interpolateThird(c0, c1, 2)\n            ];\n\n            // Decode 4x4 block\n            for (let y = 0; y < 4; y++) {\n                for (let x = 0; x < 4; x++) {\n                    const px = bx * 4 + x;\n                    const py = by * 4 + y;\n\n                    if (px < width && py < height) {\n                        const i = y * 4 + x;\n                        const colorIndex = (indices >> (i * 2)) & 0b11;\n                        const color = colors[colorIndex];\n\n                        const dstIdx = (py * width + px) * 4;\n                        rgba[dstIdx] = color.r;\n                        rgba[dstIdx + 1] = color.g;\n                        rgba[dstIdx + 2] = color.b;\n                        rgba[dstIdx + 3] = alphas[i];\n                    }\n                }\n            }\n\n            offset += 16;\n        }\n    }\n\n    return rgba;\n}\n", "/**\n * BC4 Decoder - Single channel compression\n * Source: https://github.com/Nominom/BCnEncoder.NET\n */\n\nimport { interpolateByteFifth, interpolateByteSeventh } from './utils';\n\nfunction decodeComponentBlock(componentData: bigint): number[] {\n    const output = new Array<number>(16);\n\n    const c0 = Number(componentData & 0xFFn);\n    const c1 = Number((componentData >> 8n) & 0xFFn);\n\n    // Build component palette\n    const components = c0 > c1 ? [\n        c0,\n        c1,\n        interpolateByteSeventh(c0, c1, 1),\n        interpolateByteSeventh(c0, c1, 2),\n        interpolateByteSeventh(c0, c1, 3),\n        interpolateByteSeventh(c0, c1, 4),\n        interpolateByteSeventh(c0, c1, 5),\n        interpolateByteSeventh(c0, c1, 6)\n    ] : [\n        c0,\n        c1,\n        interpolateByteFifth(c0, c1, 1),\n        interpolateByteFifth(c0, c1, 2),\n        interpolateByteFifth(c0, c1, 3),\n        interpolateByteFifth(c0, c1, 4),\n        0,\n        255\n    ];\n\n    // Decode indices (3 bits per pixel, 48 bits total starting at bit 16)\n    for (let i = 0; i < 16; i++) {\n        const bitOffset = 16 + i * 3;\n        const index = Number((componentData >> BigInt(bitOffset)) & 0x7n);\n        output[i] = components[index];\n    }\n\n    return output;\n}\n\nexport function decodeBC4(data: DataView, width: number, height: number, channel: 'r' | 'g' | 'b' | 'a' = 'r'): Uint8Array {\n    const rgba = new Uint8Array(width * height * 4);\n    const blocksX = Math.ceil(width / 4);\n    const blocksY = Math.ceil(height / 4);\n\n    const channelMap = { r: 0, g: 1, b: 2, a: 3 };\n    const outputChannel = channelMap[channel];\n\n    let offset = 0;\n    for (let by = 0; by < blocksY; by++) {\n        for (let bx = 0; bx < blocksX; bx++) {\n            const componentBlock = data.getBigUint64(offset, true);\n            const components = decodeComponentBlock(componentBlock);\n\n            // Decode 4x4 block\n            for (let y = 0; y < 4; y++) {\n                for (let x = 0; x < 4; x++) {\n                    const px = bx * 4 + x;\n                    const py = by * 4 + y;\n\n                    if (px < width && py < height) {\n                        const i = y * 4 + x;\n                        const dstIdx = (py * width + px) * 4;\n\n                        // Initialize to default\n                        rgba[dstIdx] = 0;\n                        rgba[dstIdx + 1] = 0;\n                        rgba[dstIdx + 2] = 0;\n                        rgba[dstIdx + 3] = 255;\n\n                        // Set the decoded channel\n                        rgba[dstIdx + outputChannel] = components[i];\n                    }\n                }\n            }\n\n            offset += 8;\n        }\n    }\n\n    return rgba;\n}\n", "/**\n * BC5 Decoder - Two channel compression (typically for normal maps)\n * Source: https://github.com/Nominom/BCnEncoder.NET\n */\n\nimport { interpolateByteFifth, interpolateByteSeventh } from './utils';\n\nfunction decodeComponentBlock(componentData: bigint): number[] {\n    const output = new Array<number>(16);\n\n    const c0 = Number(componentData & 0xFFn);\n    const c1 = Number((componentData >> 8n) & 0xFFn);\n\n    // Build component palette\n    const components = c0 > c1 ? [\n        c0,\n        c1,\n        interpolateByteSeventh(c0, c1, 1),\n        interpolateByteSeventh(c0, c1, 2),\n        interpolateByteSeventh(c0, c1, 3),\n        interpolateByteSeventh(c0, c1, 4),\n        interpolateByteSeventh(c0, c1, 5),\n        interpolateByteSeventh(c0, c1, 6)\n    ] : [\n        c0,\n        c1,\n        interpolateByteFifth(c0, c1, 1),\n        interpolateByteFifth(c0, c1, 2),\n        interpolateByteFifth(c0, c1, 3),\n        interpolateByteFifth(c0, c1, 4),\n        0,\n        255\n    ];\n\n    // Decode indices (3 bits per pixel, 48 bits total starting at bit 16)\n    for (let i = 0; i < 16; i++) {\n        const bitOffset = 16 + i * 3;\n        const index = Number((componentData >> BigInt(bitOffset)) & 0x7n);\n        output[i] = components[index];\n    }\n\n    return output;\n}\n\nexport function decodeBC5(\n    data: DataView, \n    width: number, \n    height: number,\n    channel1: 'r' | 'g' | 'b' | 'a' = 'r',\n    channel2: 'r' | 'g' | 'b' | 'a' = 'g'\n): Uint8Array {\n    const rgba = new Uint8Array(width * height * 4);\n    const blocksX = Math.ceil(width / 4);\n    const blocksY = Math.ceil(height / 4);\n\n    const channelMap = { r: 0, g: 1, b: 2, a: 3 };\n    const outputChannel1 = channelMap[channel1];\n    const outputChannel2 = channelMap[channel2];\n\n    let offset = 0;\n    for (let by = 0; by < blocksY; by++) {\n        for (let bx = 0; bx < blocksX; bx++) {\n            // Read red channel block\n            const redBlock = data.getBigUint64(offset, true);\n            const reds = decodeComponentBlock(redBlock);\n\n            // Read green channel block\n            const greenBlock = data.getBigUint64(offset + 8, true);\n            const greens = decodeComponentBlock(greenBlock);\n\n            // Decode 4x4 block\n            for (let y = 0; y < 4; y++) {\n                for (let x = 0; x < 4; x++) {\n                    const px = bx * 4 + x;\n                    const py = by * 4 + y;\n\n                    if (px < width && py < height) {\n                        const i = y * 4 + x;\n                        const dstIdx = (py * width + px) * 4;\n\n                        // Initialize to default\n                        rgba[dstIdx] = 0;\n                        rgba[dstIdx + 1] = 0;\n                        rgba[dstIdx + 2] = 0;\n                        rgba[dstIdx + 3] = 255;\n\n                        // Set the decoded channels\n                        rgba[dstIdx + outputChannel1] = reds[i];\n                        rgba[dstIdx + outputChannel2] = greens[i];\n                    }\n                }\n            }\n\n            offset += 16;\n        }\n    }\n\n    return rgba;\n}\n", "/**\n * BC7 Decoder - Direct port from BCnEnc.Net\n * Source: https://github.com/Nominom/BCnEncoder.NET\n */\n\nimport { ColorRgba32 } from './utils';\n\n// ByteHelper utilities\n// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nclass ByteHelper {\n    static extract(source: bigint, index: number, bitCount: number): number {\n        const mask = (1n << BigInt(bitCount)) - 1n;\n        return Number((source >> BigInt(index)) & mask);\n    }\n\n    static extractFrom128(low: bigint, high: bigint, index: number, bitCount: number): number {\n        // Extract from low\n        if (index + bitCount <= 64) {\n            return ByteHelper.extract(low, index, bitCount);\n        }\n\n        // Extract from high\n        if (index >= 64) {\n            return ByteHelper.extract(high, index - 64, bitCount);\n        }\n\n        // Handle boundary case\n        const lowBitCount = 64 - index;\n        const highBitCount = bitCount - lowBitCount;\n\n        const lowValue = ByteHelper.extract(low, index, lowBitCount);\n        const highValue = ByteHelper.extract(high, 0, highBitCount);\n        \n        return lowValue | (highValue << lowBitCount);\n    }\n\n    static extract1(source: bigint, index: number): number {\n        return Number((source >> BigInt(index)) & 1n);\n    }\n\n    static extract2(source: bigint, index: number): number {\n        return Number((source >> BigInt(index)) & 3n);\n    }\n\n    static extract4(source: bigint, index: number): number {\n        return Number((source >> BigInt(index)) & 15n);\n    }\n\n    static extract6(source: bigint, index: number): number {\n        return Number((source >> BigInt(index)) & 63n);\n    }\n}\n\n// Interpolation weights\nconst COLOR_WEIGHTS_2 = [0, 21, 43, 64];\nconst COLOR_WEIGHTS_3 = [0, 9, 18, 27, 37, 46, 55, 64];\nconst COLOR_WEIGHTS_4 = [0, 4, 9, 13, 17, 21, 26, 30, 34, 38, 43, 47, 51, 55, 60, 64];\n\nfunction interpolateByte(e0: number, e1: number, index: number, indexPrecision: number): number {\n    if (indexPrecision === 0) return e0;\n    \n    const weights = indexPrecision === 2 ? COLOR_WEIGHTS_2 :\n                   indexPrecision === 3 ? COLOR_WEIGHTS_3 :\n                   COLOR_WEIGHTS_4;\n    \n    const w = weights[index];\n    return ((64 - w) * e0 + w * e1 + 32) >> 6;\n}\n\n// Partition tables (complete 64 patterns)\nconst SUBSETS_2_PARTITION_TABLE = [\n    [0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1],[0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1],\n    [0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,1,1,0,1,1,1],\n    [0,0,0,0,0,0,0,1,0,0,0,1,0,0,1,1],[0,0,1,1,0,1,1,1,0,1,1,1,1,1,1,1],\n    [0,0,0,1,0,0,1,1,0,1,1,1,1,1,1,1],[0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,1],\n    [0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1],[0,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1],\n    [0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1],\n    [0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1],[0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1],\n    [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1],[0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1],\n    [0,0,0,0,1,0,0,0,1,1,1,0,1,1,1,1],[0,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0],\n    [0,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0],[0,1,1,1,0,0,1,1,0,0,0,1,0,0,0,0],\n    [0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,0,0,1,0,0,0,1,1,0,0,1,1,1,0],\n    [0,0,0,0,0,0,0,0,1,0,0,0,1,1,0,0],[0,1,1,1,0,0,1,1,0,0,1,1,0,0,0,1],\n    [0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,0],[0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,0],\n    [0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0],[0,0,1,1,0,1,1,0,0,1,1,0,1,1,0,0],\n    [0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0],[0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0],\n    [0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,0],[0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,0],\n    [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],[0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1],\n    [0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0],[0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0],\n    [0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0],[0,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0],\n    [0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1],[0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,1],\n    [0,1,1,1,0,0,1,1,1,1,0,0,1,1,1,0],[0,0,0,1,0,0,1,1,1,1,0,0,1,0,0,0],\n    [0,0,1,1,0,0,1,0,0,1,0,0,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0],\n    [0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0],[0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1],\n    [0,1,1,0,0,1,1,0,1,0,0,1,1,0,0,1],[0,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0],\n    [0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0],\n    [0,0,0,0,0,0,1,0,0,1,1,1,0,0,1,0],[0,0,0,0,0,1,0,0,1,1,1,0,0,1,0,0],\n    [0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,1],[0,0,1,1,0,1,1,0,1,1,0,0,1,0,0,1],\n    [0,1,1,0,0,0,1,1,1,0,0,1,1,1,0,0],[0,0,1,1,1,0,0,1,1,1,0,0,0,1,1,0],\n    [0,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1],[0,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1],\n    [0,1,1,1,1,1,1,0,1,0,0,0,0,0,0,1],[0,0,0,1,1,0,0,0,1,1,1,0,0,1,1,1],\n    [0,0,0,0,1,1,1,1,0,0,1,1,0,0,1,1],[0,0,1,1,0,0,1,1,1,1,1,1,0,0,0,0],\n    [0,0,1,0,0,0,1,0,1,1,1,0,1,1,1,0],[0,1,0,0,0,1,0,0,0,1,1,1,0,1,1,1]\n];\n\nconst SUBSETS_3_PARTITION_TABLE = [\n    [0,0,1,1,0,0,1,1,0,2,2,1,2,2,2,2],[0,0,0,1,0,0,1,1,2,2,1,1,2,2,2,1],\n    [0,0,0,0,2,0,0,1,2,2,1,1,2,2,1,1],[0,2,2,2,0,0,2,2,0,0,1,1,0,1,1,1],\n    [0,0,0,0,0,0,0,0,1,1,2,2,1,1,2,2],[0,0,1,1,0,0,1,1,0,0,2,2,0,0,2,2],\n    [0,0,2,2,0,0,2,2,1,1,1,1,1,1,1,1],[0,0,1,1,0,0,1,1,2,2,1,1,2,2,1,1],\n    [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2],[0,0,0,0,1,1,1,1,1,1,1,1,2,2,2,2],\n    [0,0,0,0,1,1,1,1,2,2,2,2,2,2,2,2],[0,0,1,2,0,0,1,2,0,0,1,2,0,0,1,2],\n    [0,1,1,2,0,1,1,2,0,1,1,2,0,1,1,2],[0,1,2,2,0,1,2,2,0,1,2,2,0,1,2,2],\n    [0,0,1,1,0,1,1,2,1,1,2,2,1,2,2,2],[0,0,1,1,2,0,0,1,2,2,0,0,2,2,2,0],\n    [0,0,0,1,0,0,1,1,0,1,1,2,1,1,2,2],[0,1,1,1,0,0,1,1,2,0,0,1,2,2,0,0],\n    [0,0,0,0,1,1,2,2,1,1,2,2,1,1,2,2],[0,0,2,2,0,0,2,2,0,0,2,2,1,1,1,1],\n    [0,1,1,1,0,1,1,1,0,2,2,2,0,2,2,2],[0,0,0,1,0,0,0,1,2,2,2,1,2,2,2,1],\n    [0,0,0,0,0,0,1,1,0,1,2,2,0,1,2,2],[0,0,0,0,1,1,0,0,2,2,1,0,2,2,1,0],\n    [0,1,2,2,0,1,2,2,0,0,1,1,0,0,0,0],[0,0,1,2,0,0,1,2,1,1,2,2,2,2,2,2],\n    [0,1,1,0,1,2,2,1,1,2,2,1,0,1,1,0],[0,0,0,0,0,1,1,0,1,2,2,1,1,2,2,1],\n    [0,0,2,2,1,1,0,2,1,1,0,2,0,0,2,2],[0,1,1,0,0,1,1,0,2,0,0,2,2,2,2,2],\n    [0,0,1,1,0,1,2,2,0,1,2,2,0,0,1,1],[0,0,0,0,2,0,0,0,2,2,1,1,2,2,2,1],\n    [0,0,0,0,0,0,0,2,1,1,2,2,1,2,2,2],[0,2,2,2,0,0,2,2,0,0,1,2,0,0,1,1],\n    [0,0,1,1,0,0,1,2,0,0,2,2,0,2,2,2],[0,1,2,0,0,1,2,0,0,1,2,0,0,1,2,0],\n    [0,0,0,0,1,1,1,1,2,2,2,2,0,0,0,0],[0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0],\n    [0,1,2,0,2,0,1,2,1,2,0,1,0,1,2,0],[0,0,1,1,2,2,0,0,1,1,2,2,0,0,1,1],\n    [0,0,1,1,1,1,2,2,2,2,0,0,0,0,1,1],[0,1,0,1,0,1,0,1,2,2,2,2,2,2,2,2],\n    [0,0,0,0,0,0,0,0,2,1,2,1,2,1,2,1],[0,0,2,2,1,1,2,2,0,0,2,2,1,1,2,2],\n    [0,0,2,2,0,0,1,1,0,0,2,2,0,0,1,1],[0,2,2,0,1,2,2,1,0,2,2,0,1,2,2,1],\n    [0,1,0,1,2,2,2,2,2,2,2,2,0,1,0,1],[0,0,0,0,2,1,2,1,2,1,2,1,2,1,2,1],\n    [0,1,0,1,0,1,0,1,0,1,0,1,2,2,2,2],[0,2,2,2,0,1,1,1,0,2,2,2,0,1,1,1],\n    [0,0,0,2,1,1,1,2,0,0,0,2,1,1,1,2],[0,0,0,0,2,1,1,2,2,1,1,2,2,1,1,2],\n    [0,2,2,2,0,1,1,1,0,1,1,1,0,2,2,2],[0,0,0,2,1,1,1,2,1,1,1,2,0,0,0,2],\n    [0,1,1,0,0,1,1,0,0,1,1,0,2,2,2,2],[0,0,0,0,0,0,0,0,2,1,1,2,2,1,1,2],\n    [0,1,1,0,0,1,1,0,2,2,2,2,2,2,2,2],[0,0,2,2,0,0,1,1,0,0,1,1,0,0,2,2],\n    [0,0,2,2,1,1,2,2,1,1,2,2,0,0,2,2],[0,0,0,0,0,0,0,0,0,0,0,0,2,1,1,2],\n    [0,0,0,2,0,0,0,1,0,0,0,2,0,0,0,1],[0,2,2,2,1,2,2,2,0,2,2,2,1,2,2,2],\n    [0,1,0,1,2,2,2,2,2,2,2,2,2,2,2,2],[0,1,1,1,2,0,1,1,2,2,0,1,2,2,2,0]\n];\n\nconst SUBSETS_2_ANCHOR_INDICES = [\n    15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,\n    15,2,8,2,2,8,8,15,2,8,2,2,8,8,2,2,\n    15,15,6,8,2,8,15,15,2,8,2,2,2,15,15,6,\n    6,2,6,8,15,15,2,2,15,15,15,15,15,2,2,15\n];\n\nconst SUBSETS_3_ANCHOR_INDICES_2 = [\n    3,3,15,15,8,3,15,15,8,8,6,6,6,5,3,3,\n    3,3,8,15,3,3,6,10,5,8,8,6,8,5,15,15,\n    8,15,3,5,6,10,8,15,15,3,15,5,15,15,15,15,\n    3,15,5,5,5,8,5,10,5,10,8,13,15,12,3,3\n];\n\nconst SUBSETS_3_ANCHOR_INDICES_3 = [\n    15,8,8,3,15,15,3,8,15,15,15,15,15,15,15,8,\n    15,8,15,3,15,8,15,8,3,15,6,10,15,15,10,8,\n    15,3,15,10,10,8,9,10,6,15,8,15,3,6,6,8,\n    15,3,15,15,15,15,15,15,15,15,15,15,3,15,15,8\n];\n\nclass Bc7Block {\n    private lowBits: bigint;\n    private highBits: bigint;\n\n    constructor(data: Uint8Array) {\n        // Read 16 bytes as two 64-bit values\n        const view = new DataView(data.buffer, data.byteOffset, 16);\n        this.lowBits = view.getBigUint64(0, true);\n        this.highBits = view.getBigUint64(8, true);\n    }\n\n    private getType(): number {\n        for (let i = 0; i < 8; i++) {\n            const mask = 1n << BigInt(i);\n            if ((this.lowBits & mask) === mask) {\n                return i;\n            }\n        }\n        return 8; // Reserved\n    }\n\n    private getNumSubsets(type: number): number {\n        if (type === 0 || type === 2) return 3;\n        if (type === 1 || type === 3 || type === 7) return 2;\n        return 1;\n    }\n\n    private getPartitionSetId(type: number): number {\n        switch (type) {\n            case 0: return ByteHelper.extract4(this.lowBits, 1);\n            case 1: return ByteHelper.extract6(this.lowBits, 2);\n            case 2: return ByteHelper.extract6(this.lowBits, 3);\n            case 3: return ByteHelper.extract6(this.lowBits, 4);\n            case 7: return ByteHelper.extract6(this.lowBits, 8);\n            default: return 0;\n        }\n    }\n\n    private getRotationBits(type: number): number {\n        if (type === 4) return ByteHelper.extract2(this.lowBits, 5);\n        if (type === 5) return ByteHelper.extract2(this.lowBits, 6);\n        return 0;\n    }\n\n    private getColorComponentPrecision(type: number): number {\n        const precisions = [5, 7, 5, 8, 5, 7, 8, 6];\n        return precisions[type] || 0;\n    }\n\n    private getAlphaComponentPrecision(type: number): number {\n        if (type === 4) return 6;\n        if (type === 5 || type === 6) return 8;\n        if (type === 7) return 6;\n        return 0;\n    }\n\n    private getType4IndexMode(): number {\n        return ByteHelper.extract1(this.lowBits, 7);\n    }\n\n    private getColorIndexBitCount(type: number): number {\n        if (type === 0 || type === 1) return 3;\n        if (type === 2 || type === 3 || type === 5 || type === 7) return 2;\n        if (type === 4) {\n            const indexMode = this.getType4IndexMode();\n            return indexMode === 0 ? 2 : 3;\n        }\n        if (type === 6) return 4;\n        return 0;\n    }\n\n    private getAlphaIndexBitCount(type: number): number {\n        if (type === 4) {\n            const indexMode = this.getType4IndexMode();\n            return indexMode === 0 ? 3 : 2;\n        }\n        if (type === 5 || type === 7) return 2;\n        if (type === 6) return 4;\n        return 0;\n    }\n\n    private extractRawEndpoints(type: number, numSubsets: number): ColorRgba32[] {\n        const endpoints: ColorRgba32[] = Array(numSubsets * 2).fill(null).map(() => ({ r: 0, g: 0, b: 0, a: 0 }));\n\n        switch (type) {\n            case 0:\n                for (let i = 0; i < 6; i++) {\n                    endpoints[i].r = ByteHelper.extractFrom128(this.lowBits, this.highBits, 5 + i * 4, 4);\n                    endpoints[i].g = ByteHelper.extractFrom128(this.lowBits, this.highBits, 29 + i * 4, 4);\n                    endpoints[i].b = ByteHelper.extractFrom128(this.lowBits, this.highBits, 53 + i * 4, 4);\n                }\n                break;\n            case 1:\n                for (let i = 0; i < 4; i++) {\n                    endpoints[i].r = ByteHelper.extractFrom128(this.lowBits, this.highBits, 8 + i * 6, 6);\n                    endpoints[i].g = ByteHelper.extractFrom128(this.lowBits, this.highBits, 32 + i * 6, 6);\n                    endpoints[i].b = ByteHelper.extractFrom128(this.lowBits, this.highBits, 56 + i * 6, 6);\n                }\n                break;\n            case 2:\n                for (let i = 0; i < 6; i++) {\n                    endpoints[i].r = ByteHelper.extractFrom128(this.lowBits, this.highBits, 9 + i * 5, 5);\n                    endpoints[i].g = ByteHelper.extractFrom128(this.lowBits, this.highBits, 39 + i * 5, 5);\n                    endpoints[i].b = ByteHelper.extractFrom128(this.lowBits, this.highBits, 69 + i * 5, 5);\n                }\n                break;\n            case 3:\n                for (let i = 0; i < 4; i++) {\n                    endpoints[i].r = ByteHelper.extractFrom128(this.lowBits, this.highBits, 10 + i * 7, 7);\n                    endpoints[i].g = ByteHelper.extractFrom128(this.lowBits, this.highBits, 38 + i * 7, 7);\n                    endpoints[i].b = ByteHelper.extractFrom128(this.lowBits, this.highBits, 66 + i * 7, 7);\n                }\n                break;\n            case 4:\n                endpoints[0].r = ByteHelper.extractFrom128(this.lowBits, this.highBits, 8, 5);\n                endpoints[1].r = ByteHelper.extractFrom128(this.lowBits, this.highBits, 13, 5);\n                endpoints[0].g = ByteHelper.extractFrom128(this.lowBits, this.highBits, 18, 5);\n                endpoints[1].g = ByteHelper.extractFrom128(this.lowBits, this.highBits, 23, 5);\n                endpoints[0].b = ByteHelper.extractFrom128(this.lowBits, this.highBits, 28, 5);\n                endpoints[1].b = ByteHelper.extractFrom128(this.lowBits, this.highBits, 33, 5);\n                endpoints[0].a = ByteHelper.extractFrom128(this.lowBits, this.highBits, 38, 6);\n                endpoints[1].a = ByteHelper.extractFrom128(this.lowBits, this.highBits, 44, 6);\n                break;\n            case 5:\n                endpoints[0].r = ByteHelper.extractFrom128(this.lowBits, this.highBits, 8, 7);\n                endpoints[1].r = ByteHelper.extractFrom128(this.lowBits, this.highBits, 15, 7);\n                endpoints[0].g = ByteHelper.extractFrom128(this.lowBits, this.highBits, 22, 7);\n                endpoints[1].g = ByteHelper.extractFrom128(this.lowBits, this.highBits, 29, 7);\n                endpoints[0].b = ByteHelper.extractFrom128(this.lowBits, this.highBits, 36, 7);\n                endpoints[1].b = ByteHelper.extractFrom128(this.lowBits, this.highBits, 43, 7);\n                endpoints[0].a = ByteHelper.extractFrom128(this.lowBits, this.highBits, 50, 8);\n                endpoints[1].a = ByteHelper.extractFrom128(this.lowBits, this.highBits, 58, 8);\n                break;\n            case 6:\n                endpoints[0].r = ByteHelper.extractFrom128(this.lowBits, this.highBits, 7, 7);\n                endpoints[1].r = ByteHelper.extractFrom128(this.lowBits, this.highBits, 14, 7);\n                endpoints[0].g = ByteHelper.extractFrom128(this.lowBits, this.highBits, 21, 7);\n                endpoints[1].g = ByteHelper.extractFrom128(this.lowBits, this.highBits, 28, 7);\n                endpoints[0].b = ByteHelper.extractFrom128(this.lowBits, this.highBits, 35, 7);\n                endpoints[1].b = ByteHelper.extractFrom128(this.lowBits, this.highBits, 42, 7);\n                endpoints[0].a = ByteHelper.extractFrom128(this.lowBits, this.highBits, 49, 7);\n                endpoints[1].a = ByteHelper.extractFrom128(this.lowBits, this.highBits, 56, 7);\n                break;\n            case 7:\n                for (let i = 0; i < 4; i++) {\n                    endpoints[i].r = ByteHelper.extractFrom128(this.lowBits, this.highBits, 14 + i * 5, 5);\n                    endpoints[i].g = ByteHelper.extractFrom128(this.lowBits, this.highBits, 34 + i * 5, 5);\n                    endpoints[i].b = ByteHelper.extractFrom128(this.lowBits, this.highBits, 54 + i * 5, 5);\n                    endpoints[i].a = ByteHelper.extractFrom128(this.lowBits, this.highBits, 74 + i * 5, 5);\n                }\n                break;\n        }\n\n        return endpoints;\n    }\n\n    private extractPBits(type: number, _numSubsets: number): number[] {\n        switch (type) {\n            case 0:\n                return [\n                    ByteHelper.extract1(this.highBits, 77 - 64),\n                    ByteHelper.extract1(this.highBits, 78 - 64),\n                    ByteHelper.extract1(this.highBits, 79 - 64),\n                    ByteHelper.extract1(this.highBits, 80 - 64),\n                    ByteHelper.extract1(this.highBits, 81 - 64),\n                    ByteHelper.extract1(this.highBits, 82 - 64)\n                ];\n            case 1:\n                return [\n                    ByteHelper.extract1(this.highBits, 80 - 64),\n                    ByteHelper.extract1(this.highBits, 81 - 64)\n                ];\n            case 3:\n                return [\n                    ByteHelper.extract1(this.highBits, 94 - 64),\n                    ByteHelper.extract1(this.highBits, 95 - 64),\n                    ByteHelper.extract1(this.highBits, 96 - 64),\n                    ByteHelper.extract1(this.highBits, 97 - 64)\n                ];\n            case 6:\n                return [\n                    ByteHelper.extract1(this.lowBits, 63),\n                    ByteHelper.extract1(this.highBits, 0)\n                ];\n            case 7:\n                return [\n                    ByteHelper.extract1(this.highBits, 94 - 64),\n                    ByteHelper.extract1(this.highBits, 95 - 64),\n                    ByteHelper.extract1(this.highBits, 96 - 64),\n                    ByteHelper.extract1(this.highBits, 97 - 64)\n                ];\n            default:\n                return [];\n        }\n    }\n\n    private hasPBits(type: number): boolean {\n        return type === 0 || type === 1 || type === 3 || type === 6 || type === 7;\n    }\n\n    private hasAlpha(type: number): boolean {\n        return type === 4 || type === 5 || type === 6 || type === 7;\n    }\n\n    private finalizeEndpoints(endpoints: ColorRgba32[], type: number): void {\n        const hasPBits = this.hasPBits(type);\n        \n        if (hasPBits) {\n            const pBits = this.extractPBits(type, endpoints.length);\n            \n            // Left shift by 1\n            for (const ep of endpoints) {\n                ep.r <<= 1;\n                ep.g <<= 1;\n                ep.b <<= 1;\n                ep.a <<= 1;\n            }\n\n            // Apply P-bits\n            if (type === 1) {\n                // Shared P-bits for Type 1\n                endpoints[0].r |= pBits[0]; endpoints[0].g |= pBits[0]; endpoints[0].b |= pBits[0];\n                endpoints[1].r |= pBits[0]; endpoints[1].g |= pBits[0]; endpoints[1].b |= pBits[0];\n                endpoints[2].r |= pBits[1]; endpoints[2].g |= pBits[1]; endpoints[2].b |= pBits[1];\n                endpoints[3].r |= pBits[1]; endpoints[3].g |= pBits[1]; endpoints[3].b |= pBits[1];\n            } else {\n                for (let i = 0; i < endpoints.length; i++) {\n                    endpoints[i].r |= pBits[i];\n                    endpoints[i].g |= pBits[i];\n                    endpoints[i].b |= pBits[i];\n                    if (this.hasAlpha(type)) {\n                        endpoints[i].a |= pBits[i];\n                    }\n                }\n            }\n        }\n\n        const colorPrec = this.getColorComponentPrecision(type);\n        const alphaPrec = this.getAlphaComponentPrecision(type);\n\n        for (const ep of endpoints) {\n            // Left shift to place MSB in bit 7\n            ep.r = (ep.r << (8 - colorPrec)) | (ep.r >> (colorPrec - (8 - colorPrec)));\n            ep.g = (ep.g << (8 - colorPrec)) | (ep.g >> (colorPrec - (8 - colorPrec)));\n            ep.b = (ep.b << (8 - colorPrec)) | (ep.b >> (colorPrec - (8 - colorPrec)));\n            ep.a = alphaPrec > 0 \n                ? (ep.a << (8 - alphaPrec)) | (ep.a >> (alphaPrec - (8 - alphaPrec)))\n                : 255;\n        }\n\n        if (!this.hasAlpha(type)) {\n            for (const ep of endpoints) {\n                ep.a = 255;\n            }\n        }\n    }\n\n    private getPartitionIndex(numSubsets: number, partitionSetId: number, pixelIndex: number): number {\n        if (numSubsets === 1) return 0;\n        if (numSubsets === 2) return SUBSETS_2_PARTITION_TABLE[partitionSetId][pixelIndex];\n        return SUBSETS_3_PARTITION_TABLE[partitionSetId][pixelIndex];\n    }\n\n    private getIndexBegin(type: number, bitCount: number, isAlpha: boolean): number {\n        switch (type) {\n            case 0: return 83;\n            case 1: return 82;\n            case 2: return 99;\n            case 3: return 98;\n            case 4: return bitCount === 2 ? 50 : 81;\n            case 5: return isAlpha ? 97 : 66;\n            case 6: return 65;\n            case 7: return 98;\n            default: return 0;\n        }\n    }\n\n    private getIndexBitCount(numSubsets: number, partitionIndex: number, bitCount: number, pixelIndex: number): number {\n        if (pixelIndex === 0) return bitCount - 1;\n        \n        if (numSubsets === 2) {\n            const anchorIndex = SUBSETS_2_ANCHOR_INDICES[partitionIndex];\n            if (pixelIndex === anchorIndex) return bitCount - 1;\n        } else if (numSubsets === 3) {\n            const anchor2 = SUBSETS_3_ANCHOR_INDICES_2[partitionIndex];\n            const anchor3 = SUBSETS_3_ANCHOR_INDICES_3[partitionIndex];\n            if (pixelIndex === anchor2 || pixelIndex === anchor3) return bitCount - 1;\n        }\n        \n        return bitCount;\n    }\n\n    private getIndexOffset(type: number, numSubsets: number, partitionIndex: number, bitCount: number, pixelIndex: number): number {\n        if (pixelIndex === 0) return 0;\n        \n        if (numSubsets === 1) {\n            return bitCount * pixelIndex - 1;\n        }\n\n        if (numSubsets === 2) {\n            const anchorIndex = SUBSETS_2_ANCHOR_INDICES[partitionIndex];\n            if (pixelIndex <= anchorIndex) {\n                return bitCount * pixelIndex - 1;\n            } else {\n                return bitCount * pixelIndex - 2;\n            }\n        }\n\n        if (numSubsets === 3) {\n            const anchor2 = SUBSETS_3_ANCHOR_INDICES_2[partitionIndex];\n            const anchor3 = SUBSETS_3_ANCHOR_INDICES_3[partitionIndex];\n\n            if (pixelIndex <= anchor2 && pixelIndex <= anchor3) {\n                return bitCount * pixelIndex - 1;\n            } else if (pixelIndex > anchor2 && pixelIndex > anchor3) {\n                return bitCount * pixelIndex - 3;\n            } else {\n                return bitCount * pixelIndex - 2;\n            }\n        }\n\n        return 0;\n    }\n\n    private getColorIndex(type: number, numSubsets: number, partitionIndex: number, bitCount: number, pixelIndex: number): number {\n        const indexOffset = this.getIndexOffset(type, numSubsets, partitionIndex, bitCount, pixelIndex);\n        const indexBitCount = this.getIndexBitCount(numSubsets, partitionIndex, bitCount, pixelIndex);\n        const indexBegin = this.getIndexBegin(type, bitCount, false);\n        return ByteHelper.extractFrom128(this.lowBits, this.highBits, indexBegin + indexOffset, indexBitCount);\n    }\n\n    private getAlphaIndex(type: number, numSubsets: number, partitionIndex: number, bitCount: number, pixelIndex: number): number {\n        if (bitCount === 0) return 0;\n        const indexOffset = this.getIndexOffset(type, numSubsets, partitionIndex, bitCount, pixelIndex);\n        const indexBitCount = this.getIndexBitCount(numSubsets, partitionIndex, bitCount, pixelIndex);\n        const indexBegin = this.getIndexBegin(type, bitCount, true);\n        return ByteHelper.extractFrom128(this.lowBits, this.highBits, indexBegin + indexOffset, indexBitCount);\n    }\n\n    private swapChannels(color: ColorRgba32, rotation: number): ColorRgba32 {\n        switch (rotation) {\n            case 0: return color;\n            case 1: return { r: color.a, g: color.g, b: color.b, a: color.r };\n            case 2: return { r: color.r, g: color.a, b: color.b, a: color.g };\n            case 3: return { r: color.r, g: color.g, b: color.a, a: color.b };\n            default: return color;\n        }\n    }\n\n    decode(): Uint8Array {\n        const output = new Uint8Array(16 * 4);\n        const type = this.getType();\n\n        if (type === 8) {\n            // Reserved type - return error color (magenta)\n            for (let i = 0; i < 16; i++) {\n                output[i * 4] = 255;\n                output[i * 4 + 1] = 0;\n                output[i * 4 + 2] = 255;\n                output[i * 4 + 3] = 255;\n            }\n            return output;\n        }\n\n        const numSubsets = this.getNumSubsets(type);\n        const partitionSetId = this.getPartitionSetId(type);\n        const rotation = this.getRotationBits(type);\n\n        const endpoints = this.extractRawEndpoints(type, numSubsets);\n        this.finalizeEndpoints(endpoints, type);\n\n        const colorBitCount = this.getColorIndexBitCount(type);\n        const alphaBitCount = this.getAlphaIndexBitCount(type);\n\n        for (let i = 0; i < 16; i++) {\n            const subsetIndex = this.getPartitionIndex(numSubsets, partitionSetId, i);\n            const ep0 = endpoints[2 * subsetIndex];\n            const ep1 = endpoints[2 * subsetIndex + 1];\n\n            const colorIndex = this.getColorIndex(type, numSubsets, partitionSetId, colorBitCount, i);\n            const alphaIndex = this.getAlphaIndex(type, numSubsets, partitionSetId, alphaBitCount, i);\n\n            let color: ColorRgba32 = {\n                r: interpolateByte(ep0.r, ep1.r, colorIndex, colorBitCount),\n                g: interpolateByte(ep0.g, ep1.g, colorIndex, colorBitCount),\n                b: interpolateByte(ep0.b, ep1.b, colorIndex, colorBitCount),\n                a: interpolateByte(ep0.a, ep1.a, alphaIndex, alphaBitCount || colorBitCount)\n            };\n\n            if (rotation > 0) {\n                color = this.swapChannels(color, rotation);\n            }\n\n            output[i * 4] = color.r;\n            output[i * 4 + 1] = color.g;\n            output[i * 4 + 2] = color.b;\n            output[i * 4 + 3] = color.a;\n        }\n\n        return output;\n    }\n}\n\nexport function decodeBC7(imageData: DataView, width: number, height: number): Uint8Array {\n    const rgba = new Uint8Array(width * height * 4);\n    const blocksX = Math.ceil(width / 4);\n    const blocksY = Math.ceil(height / 4);\n\n    let offset = 0;\n    for (let by = 0; by < blocksY; by++) {\n        for (let bx = 0; bx < blocksX; bx++) {\n            const blockData = new Uint8Array(16);\n            for (let i = 0; i < 16; i++) {\n                blockData[i] = imageData.getUint8(offset + i);\n            }\n            \n            const block = new Bc7Block(blockData);\n            const decodedBlock = block.decode();\n\n            for (let y = 0; y < 4; y++) {\n                for (let x = 0; x < 4; x++) {\n                    const px = bx * 4 + x;\n                    const py = by * 4 + y;\n                    \n                    if (px < width && py < height) {\n                        const srcIdx = (y * 4 + x) * 4;\n                        const dstIdx = (py * width + px) * 4;\n                        rgba[dstIdx] = decodedBlock[srcIdx];\n                        rgba[dstIdx + 1] = decodedBlock[srcIdx + 1];\n                        rgba[dstIdx + 2] = decodedBlock[srcIdx + 2];\n                        rgba[dstIdx + 3] = decodedBlock[srcIdx + 3];\n                    }\n                }\n            }\n\n            offset += 16;\n        }\n    }\n\n    return rgba;\n}\n", "import { PaaType } from './PaaType';\nimport { Palette } from './Palette';\nimport { decodeBC1, decodeBC2, decodeBC3 } from '@bis-toolkit/bcn';\n\n/**\n * Pixel format conversion utilities\n */\n// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nexport class PixelFormatConversion {\n    private static setColor(img: Uint8Array, offset: number, a: number, r: number, g: number, b: number): void {\n        img[offset] = b;\n        img[offset + 1] = g;\n        img[offset + 2] = r;\n        img[offset + 3] = a;\n    }\n\n    static argb16ToArgb32(src: Buffer | Uint8Array): Uint8Array {\n        const dst = new Uint8Array(src.length * 2);\n        const nPixel = Math.floor(src.length / 2);\n        \n        for (let index = 0; index < nPixel; index++) {\n            const hbyte = src[index * 2 + 1];\n            const lbyte = src[index * 2];\n            const lhbyte = hbyte & 0x0f;\n            const hhbyte = (hbyte & 0xf0) >> 4;\n            const llbyte = lbyte & 0x0f;\n            const hlbyte = (lbyte & 0xf0) >> 4;\n            const b = Math.floor(lhbyte * 255 / 15);\n            const a = Math.floor(hhbyte * 255 / 15);\n            const r = Math.floor(llbyte * 255 / 15);\n            const g = Math.floor(hlbyte * 255 / 15);\n\n            this.setColor(dst, index * 4, a, r, g, b);\n        }\n\n        return dst;\n    }\n\n    static argb1555ToArgb32(src: Buffer | Uint8Array): Uint8Array {\n        const dst = new Uint8Array(src.length * 2);\n        const nPixel = Math.floor(src.length / 2);\n        const view = new DataView(src.buffer, src.byteOffset, src.byteLength);\n        \n        for (let index = 0; index < nPixel; index++) {\n            const s = view.getUint16(index * 2, true); // true = little endian\n            const abit = ((s & 0x8000) >> 15) === 1;\n            const b5bit = s & 0x001f;\n            const g5bit = (s & 0x03e0) >> 5;\n            const r5bit = (s & 0x7c00) >> 10;\n            const b = Math.floor(b5bit * 255 / 31);\n            const a = abit ? 255 : 0;\n            const r = Math.floor(r5bit * 255 / 31);\n            const g = Math.floor(g5bit * 255 / 31);\n\n            this.setColor(dst, index * 4, a, r, g, b);\n        }\n\n        return dst;\n    }\n\n    static ai88ToArgb32(src: Buffer | Uint8Array): Uint8Array {\n        const dst = new Uint8Array(src.length * 2);\n        const nPixel = Math.floor(src.length / 2);\n        \n        for (let index = 0; index < nPixel; index++) {\n            const grey = src[index * 2];\n            const alpha = src[index * 2 + 1];\n\n            this.setColor(dst, index * 4, alpha, grey, grey, grey);\n        }\n\n        return dst;\n    }\n\n    static p8ToARGB32(src: Buffer | Uint8Array, palette: Palette): Uint8Array {\n        const dst = new Uint8Array(src.length * 4);\n        const colors = palette.colors;\n        const nPixel = src.length;\n        \n        for (let index = 0; index < nPixel; index++) {\n            const color = colors[src[index]];\n            this.setColor(dst, index * 4, color.alpha, color.red, color.green, color.blue);\n        }\n\n        return dst;\n    }\n    static dxtToRgba32(data: Buffer | Uint8Array, width: number, height: number, format: string, useAlpha = true): Uint8Array {\n        const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n        \n        let rgba: Uint8Array;\n        switch (format) {\n            case 'BC1':\n                rgba = decodeBC1(dataView, width, height, useAlpha);\n                break;\n            case 'BC2':\n                rgba = decodeBC2(dataView, width, height);\n                break;\n            case 'BC3':\n                rgba = decodeBC3(dataView, width, height);\n                break;\n            default:\n                throw new Error(`Unsupported DXT format: ${format}`);\n        }\n        \n        // BCn decoders return RGBA, but we need BGRA to match our other conversions\n        const bgra = new Uint8Array(rgba.length);\n        for (let i = 0; i < rgba.length; i += 4) {\n            bgra[i] = rgba[i + 2];     // B\n            bgra[i + 1] = rgba[i + 1]; // G\n            bgra[i + 2] = rgba[i];     // R\n            bgra[i + 3] = rgba[i + 3]; // A\n        }\n        return bgra;\n    }\n\n    static convertToARGB32(data: Buffer | Uint8Array, width: number, height: number, type: PaaType): Uint8Array {\n        switch (type) {\n            case PaaType.DXT1:\n                return this.dxtToRgba32(data, width, height, 'BC1');\n            case PaaType.DXT2:\n                return this.dxtToRgba32(data, width, height, 'BC2');\n            case PaaType.DXT3:\n                return this.dxtToRgba32(data, width, height, 'BC2');\n            case PaaType.DXT4:\n                return this.dxtToRgba32(data, width, height, 'BC3');\n            case PaaType.DXT5:\n                return this.dxtToRgba32(data, width, height, 'BC3');\n            case PaaType.RGBA_5551:\n                return this.argb1555ToArgb32(data);\n            case PaaType.RGBA_4444:\n                return this.argb16ToArgb32(data);\n            case PaaType.AI88:\n                return this.ai88ToArgb32(data);\n            case PaaType.RGBA_8888:\n                return data instanceof Uint8Array ? data : new Uint8Array(data);\n            default:\n                throw new Error(`Unsupported PaaType: ${String(type)}`);\n        }\n    }\n}\n", "import { PaaType } from './PaaType';\nimport { BinaryReader } from '@bis-toolkit/utils';\nimport { PixelFormatConversion } from './FormatConverter';\nimport { lzoDecompress } from '@bis-toolkit/utils';\nimport { lzssDecompress } from '@bis-toolkit/utils';\n\n/**\n * Represents a single mipmap level in a PAA texture\n */\nexport class Mipmap {\n    public width = 0;\n    public height = 0;\n    public isLzss = false;\n    public isLzo = false;\n\n    private dataOffset = 0;\n    private dataSize = 0;\n    private rawData: Buffer | Uint8Array | null = null;\n    private format!: PaaType;\n\n    constructor(format: PaaType);\n    constructor(width: number, height: number, data: Buffer | Uint8Array, format: PaaType);\n    constructor(\n        formatOrWidth: PaaType | number,\n        height?: number,\n        data?: Buffer | Uint8Array,\n        format?: PaaType\n    ) {\n        // Distinguish between single-param constructor (format only) vs multi-param (width, height, data, format)\n        // If height is provided, it's the multi-param constructor\n        if (height !== undefined && data !== undefined && format !== undefined) {\n            // Constructor with width, height, data, format\n            this.width = formatOrWidth;\n            this.height = height;\n            this.format = format;\n            if (this.width * this.height > 16384) { // 128x128\n                this.isLzo = true;\n            }\n            this.dataOffset = -1;\n            if (this.isLzo) {\n                // TODO: Implement LZO compression\n                // this.rawData = lzoCompress(data);\n                this.rawData = data instanceof Uint8Array ? data : data;\n                this.dataSize = this.rawData?.length ?? 0;\n            } else {\n                this.rawData = data instanceof Uint8Array ? data : data;\n                this.dataSize = data?.length ?? 0;\n            }\n        } else {\n            // Constructor with just format\n            this.format = formatOrWidth as PaaType;\n        }\n    }\n\n    read(br: BinaryReader): void {\n        this.width = br.readUInt16();\n        this.height = br.readUInt16();\n\n        // Special 1234 x 8765 signature for LZSS\n        if (this.width === 1234 && this.height === 8765) {\n            this.width = br.readUInt16();\n            this.height = br.readUInt16();\n            this.isLzss = true;\n        }\n\n        // Arma 2 LZO compression - top bit of width set\n        if ((this.width & 0x8000) !== 0) {\n            this.width &= 0x7fff;\n            this.isLzo = true;\n        }\n\n        this.dataSize = br.readInt24();\n        this.dataOffset = br.pos;\n        br.seek(this.dataSize, 'current');\n    }\n\n    getRawPixelData(buffer: Buffer | Uint8Array): Uint8Array {\n        if (this.dataOffset === -1) {\n            throw new Error('Data offset is not set');\n        }\n\n        const br = new BinaryReader(buffer);\n        br.seek(this.dataOffset);\n\n        let uncompressedSize = this.width * this.height;\n\n        switch (this.format) {\n            case PaaType.DXT1:\n                uncompressedSize = Math.floor(uncompressedSize / 2);\n                // Fall through\n            case PaaType.DXT2:\n            case PaaType.DXT3:\n            case PaaType.DXT4:\n            case PaaType.DXT5:\n                if (!this.isLzo) {\n                    uncompressedSize = this.dataSize;\n                }\n                break;\n            case PaaType.RGBA_5551:\n            case PaaType.RGBA_4444:\n            case PaaType.AI88:\n                uncompressedSize *= 2;\n                this.isLzss = uncompressedSize > 1023;\n                break;\n            case PaaType.RGBA_8888:\n                uncompressedSize *= 4;\n                break;\n        }\n\n        if (this.isLzo) {\n            const compressedData = br.readBytes(this.dataSize);\n            return lzoDecompress(compressedData, uncompressedSize);\n        }\n        if (!this.isLzss) {\n            return br.readBytes(this.dataSize);\n        }\n        \n        // LZSS decompression\n        const result = lzssDecompress(buffer, br.pos, uncompressedSize, false);\n        br.seek(result.bytesRead, 'current');\n        return result.data;\n    }\n\n    getRgba32PixelData(buffer: Buffer | Uint8Array): Uint8Array {\n        const data = this.getRawPixelData(buffer);\n        return PixelFormatConversion.convertToARGB32(data, this.width, this.height, this.format);\n    }\n}\n", "/**\n * Channel swizzle operations\n */\nexport enum ChannelSwizzle {\n    Alpha = 0,\n    Red = 1,\n    Green = 2,\n    Blue = 3,\n    InvertedAlpha = 4,\n    InvertedRed = 5,\n    InvertedGreen = 6,\n    InvertedBlue = 7,\n    One = 8\n}\n\n/**\n * RGBA swizzle configuration\n */\nexport class RgbaSwizzle {\n    public swizBlue: ChannelSwizzle = ChannelSwizzle.Blue;\n    public swizGreen: ChannelSwizzle = ChannelSwizzle.Green;\n    public swizRed: ChannelSwizzle = ChannelSwizzle.Red;\n    public swizAlpha: ChannelSwizzle = ChannelSwizzle.Alpha;\n\n    static readonly Default = new RgbaSwizzle();\n\n    equals(other: RgbaSwizzle): boolean {\n        return this.swizBlue === other.swizBlue &&\n               this.swizGreen === other.swizGreen &&\n               this.swizRed === other.swizRed &&\n               this.swizAlpha === other.swizAlpha;\n    }\n}\n\n/**\n * Utility class for applying channel swizzling to RGBA data\n */\n// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nexport class ChannelSwizzler {\n    static apply(rgbaData: Uint8Array, swizzle: RgbaSwizzle): void {\n        if (swizzle.equals(RgbaSwizzle.Default)) {\n            return;\n        }\n\n        for (let pixOffset = 0; pixOffset < rgbaData.length; pixOffset += 4) {\n            // Data is in BGRA format, so pack accordingly\n            const pixel = \n                (rgbaData[pixOffset + 2] |           // Red at bit 0\n                (rgbaData[pixOffset + 1] << 8) |     // Green at bit 8\n                (rgbaData[pixOffset] << 16) |        // Blue at bit 16\n                (rgbaData[pixOffset + 3] << 24)) >>> 0; // Alpha at bit 24\n\n            // Write back in BGRA order\n            rgbaData[pixOffset + 2] = this.transformChannel(pixel, swizzle.swizRed);   // Red\n            rgbaData[pixOffset + 1] = this.transformChannel(pixel, swizzle.swizGreen); // Green\n            rgbaData[pixOffset + 0] = this.transformChannel(pixel, swizzle.swizBlue);  // Blue\n            rgbaData[pixOffset + 3] = this.transformChannel(pixel, swizzle.swizAlpha); // Alpha\n        }\n    }\n\n    private static transformChannel(pixel: number, swizzle: ChannelSwizzle): number {\n        if (swizzle === ChannelSwizzle.One) {\n            return 0xff;\n        }\n\n        const isInverted = swizzle >= ChannelSwizzle.InvertedAlpha && \n                         swizzle <= ChannelSwizzle.InvertedBlue;\n\n        if (isInverted) {\n            swizzle = swizzle - ChannelSwizzle.InvertedAlpha + ChannelSwizzle.Alpha;\n        }\n\n        let offset: number;\n        switch (swizzle) {\n            case ChannelSwizzle.Red:\n                offset = 0;\n                break;\n            case ChannelSwizzle.Green:\n                offset = 8;\n                break;\n            case ChannelSwizzle.Blue:\n                offset = 16;\n                break;\n            case ChannelSwizzle.Alpha:\n                offset = 24;\n                break;\n            default:\n                throw new Error(`Invalid swizzle: ${swizzle}`);\n        }\n\n        const result = (pixel >>> offset) & 0xff;\n        return isInverted ? (0xff - result) : result;\n    }\n}\n", "import { PaaType } from './PaaType';\nimport { PaaColor } from './PaaColor';\nimport { Palette } from './Palette';\nimport { Mipmap } from './Mipmap';\nimport { RgbaSwizzle, ChannelSwizzle, ChannelSwizzler } from './ChannelSwizzler';\nimport { BinaryReader } from '@bis-toolkit/utils';\n\n/**\n * Main PAA file reader/writer class\n */\nexport class Paa {\n    public type: PaaType = PaaType.DXT5;\n    public isAlpha = false;\n    public isTransparent = false;\n    public averageColor: PaaColor | null = null;\n    public maxColor: PaaColor | null = null;\n    public palette: Palette = new Palette();\n    public mipmaps: Mipmap[] = [];\n    public channelSwizzle: RgbaSwizzle = RgbaSwizzle.Default;\n    \n    private procedure = '';\n\n    /**\n     * Read a PAA file from a buffer\n     */\n    read(buffer: Buffer | Uint8Array): void {\n        const br = new BinaryReader(buffer);\n        this.type = br.readUInt16() as PaaType;\n\n        let mipMapOffsets: number[] | null = null;\n\n        // Read tags\n        while (br.readRawString(4) === 'GGAT') {\n            const name = br.readRawString(4).split('').reverse().join('');\n            const len = br.readInt32();\n\n            switch (name) {\n                case 'AVGC':\n                    this.averageColor = new PaaColor(br.readUInt32());\n                    break;\n                case 'MAXC':\n                    this.maxColor = new PaaColor(br.readUInt32());\n                    break;\n                case 'FLAG':\n                    const flag = br.readInt32();\n                    if ((flag & 0x1) !== 0) {this.isAlpha = true;}\n                    if ((flag & 0x2) !== 0) {this.isTransparent = true;}\n                    break;\n                case 'SWIZ':\n                    this.channelSwizzle = new RgbaSwizzle();\n                    this.channelSwizzle.swizAlpha = br.readByte() as ChannelSwizzle;\n                    this.channelSwizzle.swizRed = br.readByte() as ChannelSwizzle;\n                    this.channelSwizzle.swizGreen = br.readByte() as ChannelSwizzle;\n                    this.channelSwizzle.swizBlue = br.readByte() as ChannelSwizzle;\n                    break;\n                case 'PROC':\n                    this.procedure = br.readRawString(len);\n                    break;\n                case 'OFFS':\n                    const nOffsets = Math.floor(len / 4);\n                    mipMapOffsets = [];\n                    for (let i = 0; i < nOffsets; i++) {\n                        mipMapOffsets.push(br.readUInt32());\n                    }\n                    break;\n                default:\n                    throw new Error(`Got unknown tag: ${name}`);\n            }\n        }\n\n        // Seek back 4 bytes (we read past the palette marker)\n        br.seek(-4, 'current');\n        this.palette.read(br);\n\n        // Read mipmaps\n        this.mipmaps = [];\n        if (mipMapOffsets !== null) {\n            for (const mipMapOffset of mipMapOffsets) {\n                if (mipMapOffset === 0) {break;}\n                br.seek(mipMapOffset, 'begin');\n                const mipmap = new Mipmap(this.type);\n                mipmap.read(br);\n                this.mipmaps.push(mipmap);\n            }\n        }\n\n        // Check terminator\n        const terminator = br.readUInt16();\n        if (terminator !== 0) {\n            throw new Error('Invalid format: terminator bytes not found');\n        }\n    }\n\n    /**\n     * Get ARGB32 pixel data for a specific mipmap level\n     */\n    getArgb32PixelData(buffer: Buffer | Uint8Array, mipLevel = 0): Uint8Array {\n        if (mipLevel < 0 || mipLevel >= this.mipmaps.length) {\n            throw new RangeError(`mipLevel ${mipLevel} out of range`);\n        }\n        const data = this.mipmaps[mipLevel].getRgba32PixelData(buffer);\n        ChannelSwizzler.apply(data, this.channelSwizzle);\n        return data;\n    }\n}\n"],
  "mappings": "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",
  "names": ["PaaType", "matched", "ChannelSwizzle"]
}
